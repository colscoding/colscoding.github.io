{"version":3,"mappings":"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","names":["FtpHistoryStore","openDB","db","e","entry","a","b","ftpHistoryStore","DEFAULT_SETTINGS","SettingsStore","stored","legacyProfile","parsed","key","value","updates","ftp","source","listener","index","settings","settingsStore","calculateNormalizedPower","powerValues","windowSize","windowSum","sumOfFourthPowers","count","avgVal","avgFourthPower","calculateIntensityFactor","normalizedPower","calculateVariabilityIndex","averagePower","calculateWork","sum","calculateWattsPerKg","power","weightKg","calculateTSS","durationSeconds","intensityFactor","tss","calculatePMCStep","prevCtl","prevAtl","ctl","atl","tsb","LapCalculator","data","laps","sortedPower","sortedHr","sortedCadence","sortedSpeed","sortedDistance","firstTs","currentLapStart","lapMarker","lapEnd","lapPower","m","lapHr","lapCadence","lapSpeed","distBefore","distIn","lapDistance","prevDistVal","lastDataTs","acc","calculateWorkoutSummary","startTime","endTime","measurements","zoneState","weight","isFullData","calcStats","values","d","powerStats","hrStats","cadenceStats","p","powerCurve","durations","getMaxForDuration","i","maxAvg","trainingLoad","variabilityIndex","work","userWeight","profileStr","profile","np","durationSec","summary","powerDist","hrDist","DB_NAME","DB_VERSION","STORE_NAME","COMPLETED_STORE","DEBUG_STORE","PMC_STORE","openDatabase","resolve","reject","request","event","database","debugStore","getPMCData","clearPMCData","savePMCData","entries","transaction","store","completed","errors","saveDebugLog","sensor","record","getDebugLogs","clearDebugLogs","saveActiveWorkout","clearActiveWorkout","loadActiveWorkout","checkStorageQuota","estimate","percent","saveCompletedWorkout","id","updateStreakAndAchievements","err","workoutDate","goalsStore","__vitePreload","n","checkAndNotifyAchievements","error","getWorkoutHistory","saveTimeout","pendingSave","throttledSave","delayMs","flushPendingSave","isIndexedDBSupported","archiveWorkout","active","toMeasurement","arr","addWorkoutToPMC","hasRecoverableWorkout","getCompletedWorkouts","getCompletedWorkout","deleteCompletedWorkout","ExceptionCode","CapacitorException","message","code","getPlatformId","win","_a","_b","createCapacitor","capCustomPlatform","cap","Plugins","getPlatform","isNativePlatform","isPluginAvailable","pluginName","plugin","registeredPlugins","getPluginHeader","h","handleError","registerPlugin","jsImplementations","registeredPlugin","platform","pluginHeader","jsImplementation","loadPluginImplementation","createPluginMethod","impl","prop","methodHeader","options","callback","createPluginMethodWrapper","remove","wrapper","args","fn","addListener","removeListener","addListenerNative","eventName","call","callbackId","proxy","_","filePath","initCapacitorGlobal","Capacitor","WebPlugin","listenerFunc","firstListener","windowListener","retainUntilConsumed","listeners","windowEventName","pluginEventName","msg","handle","arg","encode","str","decode","CapacitorCookiesPluginWeb","cookies","cookieMap","cookie","encodedKey","encodedValue","expires","path","domain","readBlobAsBase64","blob","reader","base64String","normalizeHttpHeaders","headers","originalKeys","k","buildUrlParams","params","shouldEncode","accumulator","item","buildRequestInit","extra","output","type","form","CapacitorHttpPluginWeb","requestInit","urlParams","url","response","contentType","responseType","SystemBarsStyle","SystemBarType","SystemBarsPluginWeb","SETTINGS_KEY","defaultAutoPauseSettings","defaultWorkoutMetadataSettings","defaultCountdownSettings","defaultAutoLapSettings","defaultVoiceMetrics","defaultEnhancedVoiceSettings","defaultIntervalsSettings","defaultMusicSettings","defaultSettings","getSettings","settingsJson","saveSettingsToStorage","ScanMode","ConnectionPriority","numbersToDataView","dataViewToNumbers","numberToUUID","hexStringToDataView","hex","bin","c","isEmpty","buffer","dataViewToHexString","s","webUUIDToString","uuid","mapToObject","map","obj","toUint8Array","dataView","toHexString","BluetoothLe","makeQueue","currentTask","getQueue","enabled","parseUUID","BleClientClass","result","displayStrings","resultInternal","deviceIds","services","deviceId","onDisconnect","connectionPriority","service","characteristic","writeValue","descriptor","filter","BleClient","STORAGE_KEY","DEVICE_NAMES_KEY","connectionStorage","raw","ids","name","names","parseTreadmillData","flags","offset","hasAverageSpeed","hasTotalDistance","hasInclination","rawSpeed","rawAvgSpeed","b0","b1","b2","rawDist","rawIncline","rawRamp","readUint24","parseRowerData","hasAverageStrokeRate","hasInstantaneousPace","hasAveragePace","hasInstantaneousPower","hasAveragePower","hasExpendedEnergy","hasHeartRate","hasElapsedTime","parseCrossTrainerData","hasStepCount","hasStrideCount","hasElevationGain","hasResistanceLevel","parseIndoorBikeData","hasInstantaneousCadence","hasAverageCadence","parseStepClimberData","hasFloors","hasStepRate","hasAverageStepRate","hasPositiveElevationGain","hasMetabolicEquivalent","parseRscData","speed","cadence","hasStrideLength","strideCm","distDm","BluetoothDebugService","logs","CYCLING_POWER_SERVICE","CYCLING_POWER_MEASUREMENT","HEART_RATE_SERVICE","HEART_RATE_MEASUREMENT","CYCLING_SPEED_AND_CADENCE_SERVICE","CSC_MEASUREMENT","FITNESS_MACHINE_SERVICE","TREADMILL_DATA_CHARACTERISTIC","MAX_RECONNECT_ATTEMPTS","RECONNECT_BASE_DELAY","isBleInitialized","ensureBleInitialized","connectPowerNative","previousDeviceId","statusListeners","isManualDisconnect","reconnectAttempts","deviceName","device","notifyStatus","status","connect","attemptReconnect","delay","disconnectedDeviceId","connectHeartRateNative","heartRate","connectCadenceNative","lastCrankRevs","lastCrankTime","crankRevs","crankTime","revDelta","timeDelta","timeInSeconds","rpm","connectTreadmillNative","ftmsData","connectPowerWeb","handleCharacteristicChange","connectHeartRateWeb","connectCadenceWeb","connectTreadmillWeb","server","connectRowingWeb","rowerData","connectConcept2","connectCscWeb","cadenceListeners","speedListeners","lastWheelRevs","lastWheelTime","wheelRevs","wheelTime","wheelCircumferenceMm","speedKmh","connectCrossTrainerWeb","connectIndoorBikeWeb","controlPoint","simSupported","writeControlPoint","opCode","view","writeSimulationParameters","windSpeed","grade","crr","cw","features","watts","level","connectWeightScaleWeb","parseWeightMeasurement","isImperial","hasTimestamp","hasUserId","hasBmiHeight","bmi","measurement","connectStepClimberWeb","connectRscWeb","BluetoothFactory","MockPowerSensor","MockHeartrateSensor","MockCadenceSensor"],"ignoreList":[6,8,9,10,11,12,13],"sources":["../../src/state/FtpHistoryStore.ts","../../src/state/SettingsStore.ts","../../src/calculations/trainingLoad.ts","../../src/calculations/lap-calculator.ts","../../src/calculations/summary.ts","../../src/storage/workoutStorage.ts","../../../../node_modules/.pnpm/@capacitor+core@8.0.0/node_modules/@capacitor/core/dist/index.js","../../src/config/settings.ts","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/definitions.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/conversion.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/plugin.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/queue.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/validators.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/bleClient.js","../../src/storage/connectionStorage.ts","../../src/services/bluetooth/ftms.ts","../../src/services/debug/BluetoothDebugService.ts","../../src/services/bluetooth/native-bluetooth.ts","../../src/services/bluetooth/web-bluetooth.ts","../../src/services/bluetooth/factory.ts"],"sourcesContent":["import { openDB, IDBPDatabase } from 'idb';\n\nexport interface FtpHistoryEntry {\n    date: number; // Timestamp\n    ftp: number;\n    source: 'manual' | 'test' | 'estimated' | 'initial';\n    note?: string;\n}\n\nexport class FtpHistoryStore {\n    private db: IDBPDatabase | null = null;\n    private initialized = false;\n\n    async initialize(): Promise<void> {\n        if (this.initialized) return;\n\n        try {\n            this.db = await openDB('bpt-ftp-history', 1, {\n                upgrade(db) {\n                    if (!db.objectStoreNames.contains('history')) {\n                        const store = db.createObjectStore('history', { keyPath: 'date' });\n                        store.createIndex('date', 'date');\n                    }\n                },\n            });\n            this.initialized = true;\n        } catch (e) {\n            console.error('Failed to initialize FTP history DB', e);\n        }\n    }\n\n    async addEntry(entry: FtpHistoryEntry): Promise<void> {\n        if (!this.db) await this.initialize();\n        if (!this.db) return;\n\n        try {\n            await this.db.put('history', entry);\n        } catch (e) {\n            console.error('Failed to add FTP history entry', e);\n            // Fallback?\n        }\n    }\n\n    async getHistory(): Promise<FtpHistoryEntry[]> {\n        if (!this.db) await this.initialize();\n        if (!this.db) return [];\n\n        try {\n            const history = await this.db.getAllFromIndex('history', 'date');\n            return history.sort((a, b) => b.date - a.date); // Newest first\n        } catch (e) {\n            console.error('Failed to get FTP history', e);\n            return [];\n        }\n    }\n\n    async getLatestEntry(): Promise<FtpHistoryEntry | undefined> {\n        if (!this.db) await this.initialize();\n        if (!this.db) return undefined;\n\n        try {\n            const cursor = await this.db.transaction('history').store.index('date').openCursor(null, 'prev');\n            return cursor?.value;\n        } catch (e) {\n            return undefined;\n        }\n    }\n}\n\nexport const ftpHistoryStore = new FtpHistoryStore();\n","import { openDB, IDBPDatabase } from 'idb';\nimport { ZoneDefinition, PowerZoneModel } from '../types/zones.js';\nimport { ftpHistoryStore } from './FtpHistoryStore.js';\n\nexport type { ZoneDefinition };\n\nexport interface UserSettings {\n    // User profile\n    weight: number; // kg\n    height: number; // cm\n    age: number;\n    gender: 'male' | 'female' | 'other';\n    ftp: number; // Functional Threshold Power\n    maxHeartrate: number;\n    restingHeartrate: number;\n\n    // Display preferences\n    units: 'metric' | 'imperial';\n    dateFormat: 'ISO' | 'US' | 'EU';\n    clockFormat: '12h' | '24h';\n\n    // Calculation settings\n    energyMethod: 'power' | 'heartrate' | 'combined';\n    gapThreshold: number; // seconds before resetting energy calc\n    stalenessThreshold: number; // seconds before data considered stale\n\n    // Power zones (percentage of FTP)\n    powerZones: ZoneDefinition[];\n    powerZoneModel: PowerZoneModel;\n\n    // Heart rate zones (percentage of max HR)\n    heartrateZones: ZoneDefinition[];\n}\n\nconst DEFAULT_SETTINGS: UserSettings = {\n    weight: 75,\n    height: 175,\n    age: 30,\n    gender: 'other',\n    ftp: 200,\n    maxHeartrate: 190,\n    restingHeartrate: 60,\n\n    units: 'metric',\n    dateFormat: 'ISO',\n    clockFormat: '24h',\n\n    energyMethod: 'combined',\n    gapThreshold: 20,\n    stalenessThreshold: 5,\n\n    powerZoneModel: '7',\n    powerZones: [\n        { name: 'Recovery', min: 0, max: 55, color: '#808080' },\n        { name: 'Endurance', min: 55, max: 75, color: '#2196f3' },\n        { name: 'Tempo', min: 75, max: 90, color: '#4caf50' },\n        { name: 'Threshold', min: 90, max: 105, color: '#ffeb3b' },\n        { name: 'VO2max', min: 105, max: 120, color: '#ff9800' },\n        { name: 'Anaerobic', min: 120, max: 150, color: '#f44336' },\n        { name: 'Neuromuscular', min: 150, max: 1000, color: '#9c27b0' },\n    ],\n\n    heartrateZones: [\n        { name: 'Recovery', min: 0, max: 60, color: '#808080' },\n        { name: 'Endurance', min: 60, max: 70, color: '#2196f3' },\n        { name: 'Tempo', min: 70, max: 80, color: '#4caf50' },\n        { name: 'Threshold', min: 80, max: 90, color: '#ff9800' },\n        { name: 'VO2max', min: 90, max: 100, color: '#f44336' },\n    ],\n};\n\ntype SettingsListener = (settings: UserSettings) => void;\n\nexport class SettingsStore {\n    private settings: UserSettings = { ...DEFAULT_SETTINGS };\n    private listeners: SettingsListener[] = [];\n    private db: IDBPDatabase | null = null;\n    private initialized = false;\n\n    async initialize(): Promise<void> {\n        if (this.initialized) return;\n\n        // Try-catch block for environments that don't support IndexedDB\n        try {\n            this.db = await openDB('bpt-settings', 1, {\n                upgrade(db) {\n                    db.createObjectStore('settings');\n                },\n            });\n\n            const stored = await this.db.get('settings', 'user');\n            if (stored) {\n                // Merge stored settings with defaults to handle new fields\n                this.settings = { ...DEFAULT_SETTINGS, ...stored };\n            } else {\n                // Attempt to migrate from legacy localStorage\n                try {\n                    const legacyProfile = localStorage.getItem('bpt-user-profile');\n                    if (legacyProfile) {\n                        const parsed = JSON.parse(legacyProfile);\n                        if (parsed.ftp) this.settings.ftp = Number(parsed.ftp);\n                        if (parsed.maxHr) this.settings.maxHeartrate = Number(parsed.maxHr);\n                        if (parsed.weight) this.settings.weight = Number(parsed.weight);\n                    }\n                } catch (e) {\n                    console.warn('Failed to migrate legacy settings:', e);\n                }\n            }\n        } catch (e) {\n            console.warn('Settings storage unavailable, using defaults/in-memory:', e);\n        }\n\n        this.initialized = true;\n        this.notifyListeners();\n    }\n\n    get<K extends keyof UserSettings>(key: K): UserSettings[K] {\n        return this.settings[key];\n    }\n\n    getAll(): UserSettings {\n        return { ...this.settings };\n    }\n\n    async set<K extends keyof UserSettings>(key: K, value: UserSettings[K]): Promise<void> {\n        // Intercept FTP changes\n        if (key === 'ftp' && value !== this.settings.ftp) {\n            ftpHistoryStore.addEntry({\n                date: Date.now(),\n                ftp: value as number,\n                source: 'manual', // Default to manual when using generic set\n            });\n        }\n\n        this.settings[key] = value;\n        await this.persist();\n        this.notifyListeners();\n    }\n\n    async setMultiple(updates: Partial<UserSettings>): Promise<void> {\n        // Intercept FTP changes\n        if (updates.ftp && updates.ftp !== this.settings.ftp) {\n            ftpHistoryStore.addEntry({\n                date: Date.now(),\n                ftp: updates.ftp,\n                source: 'manual', // Default to manual when using generic set\n            });\n        }\n\n        this.settings = { ...this.settings, ...updates };\n        await this.persist();\n        this.notifyListeners();\n    }\n\n    /**\n     * Update FTP and log to history\n     */\n    async updateFtp(ftp: number, source: 'manual' | 'test' | 'estimated' = 'manual'): Promise<void> {\n        if (ftp === this.settings.ftp) return;\n\n        await this.set('ftp', ftp);\n\n        // Log to history\n        ftpHistoryStore.addEntry({\n            date: Date.now(),\n            ftp,\n            source,\n        });\n    }\n\n    async reset(): Promise<void> {\n        this.settings = { ...DEFAULT_SETTINGS };\n        await this.persist();\n        this.notifyListeners();\n    }\n\n    onChange(listener: SettingsListener): () => void {\n        this.listeners.push(listener);\n        // Call immediately with current settings\n        // listener(this.getAll());\n        // Logic: maybe we shouldn't call immediate if they just subscribe?\n        // Let's stick to standard observable pattern where it calls on next change.\n        return () => {\n            const index = this.listeners.indexOf(listener);\n            if (index !== -1) this.listeners.splice(index, 1);\n        };\n    }\n\n    private async persist(): Promise<void> {\n        if (this.db) {\n            try {\n                await this.db.put('settings', this.settings, 'user');\n            } catch (e) {\n                console.error('Failed to save settings:', e);\n            }\n        }\n    }\n\n    private notifyListeners(): void {\n        const settings = this.getAll();\n        for (const listener of this.listeners) {\n            try {\n                listener(settings);\n            } catch (e) {\n                console.error('Settings listener error:', e);\n            }\n        }\n    }\n}\n\nexport const settingsStore = new SettingsStore();\n","/**\n * Training Load Calculations\n *\n * Implements TSS, NP, IF, and PMC formulas.\n *\n * @module calculations/trainingLoad\n */\n\n/**\n * Calculate Normalized Power (NP).\n *\n * Uses 30-second rolling average raised to 4th power.\n *\n * @param powerValues - Array of power values (assumed 1Hz or consistent sample rate)\n * @returns Normalized power or null if insufficient data\n */\nexport function calculateNormalizedPower(powerValues: number[]): number | null {\n    if (!powerValues || powerValues.length < 30) {\n        return null; // Need at least 30 seconds\n    }\n\n    const windowSize = 30;\n    let windowSum = 0;\n\n    // Initial window\n    for (let i = 0; i < windowSize; i++) {\n        windowSum += powerValues[i];\n    }\n\n    let sumOfFourthPowers = 0;\n    let count = 0;\n\n    // Sliding window\n    for (let i = windowSize - 1; i < powerValues.length; i++) {\n        if (i >= windowSize) {\n            windowSum = windowSum - powerValues[i - windowSize] + powerValues[i];\n        }\n\n        const avgVal = windowSum / windowSize;\n        sumOfFourthPowers += Math.pow(avgVal, 4);\n        count++;\n    }\n\n    if (count === 0) return null;\n\n    const avgFourthPower = sumOfFourthPowers / count;\n    return Math.round(Math.pow(avgFourthPower, 0.25));\n}\n\n/**\n * Calculate Intensity Factor (IF).\n *\n * IF = NP / FTP\n */\nexport function calculateIntensityFactor(normalizedPower: number, ftp: number): number {\n    if (!ftp || ftp === 0) return 0;\n    return Number((normalizedPower / ftp).toFixed(2));\n}\n\n/**\n * Calculate Variability Index (VI).\n *\n * VI = NP / Average Power\n */\nexport function calculateVariabilityIndex(normalizedPower: number, averagePower: number): number {\n    if (!averagePower || averagePower === 0) return 1.0;\n    return Number((normalizedPower / averagePower).toFixed(2));\n}\n\n/**\n * Calculate Work in Kilojoules (kJ).\n *\n * Work = Sum of Watts * seconds / 1000\n * Assumes 1Hz data.\n */\nexport function calculateWork(powerValues: number[]): number {\n    const sum = powerValues.reduce((a, b) => a + b, 0);\n    // Watts * seconds = Joules. / 1000 = kJ.\n    return Math.round(sum / 1000);\n}\n\n/**\n * Calculate Power-to-Weight Ratio (W/kg).\n */\nexport function calculateWattsPerKg(power: number, weightKg: number): number {\n    if (!weightKg || weightKg === 0) return 0;\n    return Number((power / weightKg).toFixed(2));\n}\n\n/**\n * Calculate Training Stress Score (TSS).\n *\n * TSS = (sec x NP x IF) / (FTP x 3600) x 100\n */\nexport function calculateTSS(\n    durationSeconds: number,\n    normalizedPower: number,\n    intensityFactor: number,\n    ftp: number\n): number {\n    if (!ftp || ftp === 0) return 0;\n    // Formula: (T * NP * IF) / (FTP * 3600) * 100\n    const tss = ((durationSeconds * normalizedPower * intensityFactor) / (ftp * 3600)) * 100;\n    return Math.round(tss);\n}\n\n/**\n * Perform PMC calculation step.\n *\n * @param prevCtl - Previous day's CTL (Fitness)\n * @param prevAtl - Previous day's ATL (Fatigue)\n * @param tss - Today's TSS\n * @returns { ctl, atl, tsb }\n */\nexport function calculatePMCStep(\n    prevCtl: number,\n    prevAtl: number,\n    tss: number\n): { ctl: number; atl: number; tsb: number } {\n    // Constants\n    const CTL_TC = 42; // 42 days for fitness\n    const ATL_TC = 7; // 7 days for fatigue\n\n    // Exponential Weighted Moving Average\n    // Post-hoc calculation (Coggan): Today = Yesterday + (Today_TSS - Yesterday) * (1/TC)\n    // Or standard EWMA: Today = alpha * TSS + (1 - alpha) * Yesterday\n    // where alpha = 1 - e^(-1/TC) ~ 1/TC for large TC.\n    // The standard formula: Today = Pre + (TSS - Pre) / TC\n\n    const ctl = prevCtl + (tss - prevCtl) / CTL_TC;\n    const atl = prevAtl + (tss - prevAtl) / ATL_TC;\n    const tsb = ctl - atl;\n\n    return { ctl, atl, tsb };\n}\n","import type { Measurement, MeasurementsData } from '../types/measurements.js';\n\nexport interface LapSummary {\n    number: number;\n    startTime: number;\n    endTime: number;\n    duration: number; // ms\n    avgPower: number;\n    maxPower: number;\n    avgHeartRate: number;\n    maxHeartRate: number;\n    avgCadence: number;\n    avgSpeed: number;\n    distance: number;\n}\n\nexport class LapCalculator {\n    static calculateLaps(data: MeasurementsData): LapSummary[] {\n        if (!data.laps || data.laps.length === 0) {\n            return [];\n        }\n\n        const laps: LapSummary[] = [];\n\n        // Sort data for safety (though usually sorted)\n        const sortedPower = [...data.power].sort((a, b) => a.timestamp - b.timestamp);\n        const sortedHr = [...data.heartrate].sort((a, b) => a.timestamp - b.timestamp);\n        const sortedCadence = [...data.cadence].sort((a, b) => a.timestamp - b.timestamp);\n        const sortedSpeed = [...data.speed].sort((a, b) => a.timestamp - b.timestamp);\n        const sortedDistance = [...data.distance].sort((a, b) => a.timestamp - b.timestamp);\n\n        // Find earliest timestamp\n        const firstTs = Math.min(\n            sortedPower[0]?.timestamp || Infinity,\n            sortedHr[0]?.timestamp || Infinity,\n            sortedCadence[0]?.timestamp || Infinity\n        );\n\n        if (firstTs === Infinity) return []; // No data\n\n        let currentLapStart = firstTs;\n\n        data.laps.forEach((lapMarker) => {\n            const lapEnd = lapMarker.timestamp;\n\n            // Filter data within this lap window [currentLapStart, lapEnd]\n            // Note: Use <= lapEnd to include the marker moment\n            const lapPower = sortedPower.filter((m) => m.timestamp >= currentLapStart && m.timestamp <= lapEnd);\n            const lapHr = sortedHr.filter((m) => m.timestamp >= currentLapStart && m.timestamp <= lapEnd);\n            const lapCadence = sortedCadence.filter((m) => m.timestamp >= currentLapStart && m.timestamp <= lapEnd);\n            const lapSpeed = sortedSpeed.filter((m) => m.timestamp >= currentLapStart && m.timestamp <= lapEnd);\n\n            // Distance is cumulative.\n            const distBefore = sortedDistance.filter((m) => m.timestamp < currentLapStart);\n            const distIn = sortedDistance.filter((m) => m.timestamp >= currentLapStart && m.timestamp <= lapEnd);\n\n            let lapDistance = 0;\n            if (distIn.length > 0) {\n                // Determine start distance: if prev exists, use it. Else 0.\n                const prevDistVal = distBefore.length > 0 ? distBefore[distBefore.length - 1].value : 0;\n                lapDistance = distIn[distIn.length - 1].value - prevDistVal;\n            }\n\n            laps.push({\n                number: lapMarker.number,\n                startTime: currentLapStart,\n                endTime: lapEnd,\n                duration: lapEnd - currentLapStart,\n                avgPower: this.average(lapPower),\n                maxPower: this.max(lapPower),\n                avgHeartRate: this.average(lapHr),\n                maxHeartRate: this.max(lapHr),\n                avgCadence: this.average(lapCadence),\n                avgSpeed: this.average(lapSpeed),\n                distance: lapDistance,\n            });\n\n            currentLapStart = lapEnd;\n        });\n\n        // Handle the \"current\" partial lap (after the last marker until now/end of data)\n        // If we are calculating summary for a finished workout, the last data point is the end.\n        const lastDataTs = Math.max(\n            sortedPower[sortedPower.length - 1]?.timestamp || 0,\n            sortedHr[sortedHr.length - 1]?.timestamp || 0\n        );\n\n        if (lastDataTs > currentLapStart + 1000) {\n            // Ignore if < 1s\n            const lapPower = sortedPower.filter((m) => m.timestamp >= currentLapStart);\n            const lapHr = sortedHr.filter((m) => m.timestamp >= currentLapStart);\n            const lapCadence = sortedCadence.filter((m) => m.timestamp >= currentLapStart);\n            const lapSpeed = sortedSpeed.filter((m) => m.timestamp >= currentLapStart);\n\n            const distBefore = sortedDistance.filter((m) => m.timestamp < currentLapStart);\n            const distIn = sortedDistance.filter((m) => m.timestamp >= currentLapStart);\n\n            let lapDistance = 0;\n            if (distIn.length > 0) {\n                const prevDistVal = distBefore.length > 0 ? distBefore[distBefore.length - 1].value : 0;\n                lapDistance = distIn[distIn.length - 1].value - prevDistVal;\n            }\n\n            laps.push({\n                number: laps.length + 1,\n                startTime: currentLapStart,\n                endTime: lastDataTs,\n                duration: lastDataTs - currentLapStart,\n                avgPower: this.average(lapPower),\n                maxPower: this.max(lapPower),\n                avgHeartRate: this.average(lapHr),\n                maxHeartRate: this.max(lapHr),\n                avgCadence: this.average(lapCadence),\n                avgSpeed: this.average(lapSpeed),\n                distance: lapDistance,\n            });\n        }\n\n        return laps;\n    }\n\n    private static average(data: Measurement[]): number {\n        if (data.length === 0) return 0;\n        const sum = data.reduce((acc, m) => acc + m.value, 0);\n        return Math.round(sum / data.length);\n    }\n\n    private static max(data: Measurement[]): number {\n        if (data.length === 0) return 0;\n        return Math.max(...data.map((m) => m.value));\n    }\n}\n","/**\n * Workout Summary Calculations\n *\n * @module calculations/summary\n */\n\nimport type { ZoneState, ZoneDistribution } from '../zone-state.js';\nimport {\n    calculateNormalizedPower,\n    calculateIntensityFactor,\n    calculateTSS,\n    calculateVariabilityIndex,\n    calculateWork,\n    calculateWattsPerKg,\n} from './trainingLoad.js';\n\nimport { type LapSummary, LapCalculator } from './lap-calculator.js';\n\n/**\n * Workout summary data\n */\nexport interface WorkoutSummary {\n    duration: number;\n    startTime: number;\n    endTime: number;\n    vo2MaxEstimation?: number | null;\n    power: {\n        avg: number | null;\n        max: number | null;\n        count: number;\n        wattsPerKg?: number; // Added\n    };\n    heartrate: {\n        avg: number | null;\n        max: number | null;\n        count: number;\n    };\n    cadence: {\n        avg: number | null;\n        max: number | null;\n        count: number;\n    };\n    powerZoneDistribution?: ZoneDistribution;\n    hrZoneDistribution?: ZoneDistribution;\n    powerCurve?: { duration: number; watts: number }[];\n    trainingLoad?: number;\n    intensityFactor?: number;\n    normalizedPower?: number;\n    variabilityIndex?: number; // Added\n    work?: number; // Added (kJ)\n    laps: LapSummary[];\n}\n\nimport type { MeasurementsData } from '../types/measurements.js';\n\n/**\n * Calculate workout summary statistics\n */\nexport function calculateWorkoutSummary(\n    startTime: number,\n    endTime: number,\n    // Change to accept full measurements or object with laps\n    measurements:\n        | {\n            power: { value: number; timestamp?: number }[];\n            heartrate: { value: number; timestamp?: number }[];\n            cadence: { value: number; timestamp?: number }[];\n            // Add optional laps if we want to pass them directly, or assume they are in a structure\n        }\n        | MeasurementsData,\n    zoneState?: ZoneState,\n    weight?: number\n): WorkoutSummary {\n    // Determine if input is full MeasurementsData\n    const isFullData = (m: any): m is MeasurementsData => {\n        return Array.isArray(m.laps);\n    };\n\n    let laps: LapSummary[] = [];\n\n    if (isFullData(measurements)) {\n        // powerData, hrData, cadenceData are aliases for compatibility with legacy calcStats if needed,\n        // but calcStats reads from measurements.* which are typed compatible.\n        // Calculate laps using the new calculator\n        laps = LapCalculator.calculateLaps(measurements);\n    } else {\n        // Fallback or empty laps if simplified data passed\n        // (Legacy calls might not pass full data, though typically we pass what we have)\n        laps = [];\n    }\n\n    const calcStats = (data: { value: number }[]) => {\n        if (data.length === 0) {\n            return { avg: null, max: null, count: 0 };\n        }\n        const values = data.map((d) => d.value);\n        const sum = values.reduce((a, b) => a + b, 0);\n        return {\n            avg: Math.round(sum / values.length),\n            max: Math.max(...values),\n            count: values.length,\n        };\n    };\n\n    // Calculate basic stats first\n    const powerStats = calcStats(measurements.power);\n    const hrStats = calcStats(measurements.heartrate);\n    const cadenceStats = calcStats(measurements.cadence);\n\n    // Calculate Power Curve\n    const powerValues = measurements.power.map((p) => p.value);\n    const powerCurve: { duration: number; watts: number }[] = [];\n    const durations = [1, 5, 10, 30, 60, 300, 1200, 3600]; // 1s, 5s, 10s, 30s, 1m, 5m, 20m, 1h\n\n    // Helper for sliding window max\n    const getMaxForDuration = (windowSize: number) => {\n        if (powerValues.length < windowSize) return 0;\n        let sum = 0;\n        for (let i = 0; i < windowSize; i++) sum += powerValues[i];\n        let maxAvg = sum / windowSize;\n\n        for (let i = windowSize; i < powerValues.length; i++) {\n            sum = sum - powerValues[i - windowSize] + powerValues[i];\n            if (sum / windowSize > maxAvg) maxAvg = sum / windowSize;\n        }\n        return Math.round(maxAvg);\n    };\n\n    for (const d of durations) {\n        if (powerValues.length >= d) {\n            powerCurve.push({ duration: d, watts: getMaxForDuration(d) });\n        }\n    }\n\n    let trainingLoad = 0;\n    let intensityFactor = 0;\n    let normalizedPower = 0;\n    let variabilityIndex = 0;\n    let work = 0;\n\n    // Calculate Work (kJ)\n    if (powerValues.length > 0) {\n        work = calculateWork(powerValues);\n    }\n\n    // Get User Settings (FTP, Weight)\n    let ftp = 200;\n    let userWeight = weight;\n\n    if (zoneState) {\n        if (zoneState.getFtp()) ftp = zoneState.getFtp()!;\n    }\n\n    try {\n        if (typeof localStorage !== 'undefined') {\n            const profileStr = localStorage.getItem('bpt-user-profile');\n            if (profileStr) {\n                const profile = JSON.parse(profileStr);\n                if (!zoneState?.getFtp() && profile.ftp) ftp = profile.ftp;\n                if (!userWeight && profile.weight) userWeight = profile.weight;\n            }\n        }\n    } catch (e) {\n        console.warn('Error reading profile', e);\n    }\n\n    if (powerValues.length > 0) {\n        const np = calculateNormalizedPower(powerValues);\n        if (np) {\n            normalizedPower = np;\n            intensityFactor = calculateIntensityFactor(np, ftp);\n            const durationSec = (endTime - startTime) / 1000;\n            trainingLoad = calculateTSS(durationSec, np, intensityFactor, ftp);\n\n            if (powerStats.avg) {\n                variabilityIndex = calculateVariabilityIndex(np, powerStats.avg);\n            }\n        }\n    }\n\n    const summary: WorkoutSummary = {\n        duration: endTime - startTime,\n        startTime,\n        endTime,\n        power: {\n            ...powerStats,\n            wattsPerKg:\n                userWeight && userWeight > 0 && powerStats.avg\n                    ? calculateWattsPerKg(powerStats.avg, userWeight)\n                    : undefined,\n        },\n        heartrate: hrStats,\n        cadence: cadenceStats,\n        powerCurve: powerCurve.length > 0 ? powerCurve : undefined,\n        trainingLoad: trainingLoad > 0 ? Math.round(trainingLoad) : undefined,\n        intensityFactor: intensityFactor > 0 ? parseFloat(intensityFactor.toFixed(2)) : undefined,\n        normalizedPower: normalizedPower > 0 ? normalizedPower : undefined,\n        variabilityIndex: variabilityIndex > 0 ? variabilityIndex : undefined,\n        work: work > 0 ? work : undefined,\n        laps,\n    };\n\n    // Add zone distributions if available\n    if (zoneState) {\n        const powerDist = zoneState.getPowerZoneDistribution();\n        const hrDist = zoneState.getHrZoneDistribution();\n\n        if (powerDist.totalTimeMs > 0) {\n            summary.powerZoneDistribution = powerDist;\n        }\n        if (hrDist.totalTimeMs > 0) {\n            summary.hrZoneDistribution = hrDist;\n        }\n    }\n\n    return summary;\n}\n","/**\n * IndexedDB Storage for Workout Data\n *\n * Provides persistent storage for workout recordings using IndexedDB.\n * This ensures workout data survives page refreshes, crashes, and accidental closures.\n *\n * @module storage/workoutStorage\n */\n\nimport type {\n    MeasurementsData,\n    Measurement,\n    LapMarker,\n    GpsPoint,\n    TreadmillMeasurement,\n} from '../types/measurements.js';\n\nconst DB_NAME = 'BikeTrackerDB';\nconst DB_VERSION = 5; // Bumped for PMC Stats\nconst STORE_NAME = 'activeWorkout';\nconst COMPLETED_STORE = 'completedWorkouts';\nconst DEBUG_STORE = 'rawDebugData';\nconst PMC_STORE = 'pmcStats';\n\n/**\n * Raw Debug Log Entry\n */\nexport interface DebugLogEntry {\n    id?: number;\n    timestamp: number;\n    sensor: string;\n    data: string; // Hex representation\n}\n\n/**\n * Stored workout data with metadata\n */\nexport interface StoredWorkout {\n    id: string;\n    startTime: number;\n    lastUpdated: number;\n    measurements: MeasurementsData;\n    isCompleted: boolean;\n    synced?: boolean;\n    syncedTime?: number;\n    summary?: any; // Add summary field\n}\n\n/**\n * Active workout record for recovery\n */\nexport interface ActiveWorkoutRecord {\n    id: 'current';\n    startTime: number;\n    lastUpdated: number;\n    heartrate: Measurement[];\n    power: Measurement[];\n    cadence: Measurement[];\n    speed: Measurement[];\n    distance: Measurement[];\n    altitude: Measurement[];\n    gps: GpsPoint[];\n    treadmill: TreadmillMeasurement[];\n    laps: LapMarker[];\n}\n\nlet db: IDBDatabase | null = null;\n\n/**\n * Opens the IndexedDB database, creating stores if needed\n */\nexport async function openDatabase(): Promise<IDBDatabase> {\n    if (db) return db;\n\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n        request.onerror = () => {\n            console.error('Failed to open IndexedDB:', request.error);\n            reject(request.error);\n        };\n\n        request.onsuccess = () => {\n            db = request.result;\n            resolve(db);\n        };\n\n        request.onupgradeneeded = (event) => {\n            const database = (event.target as IDBOpenDBRequest).result;\n\n            // Store for the currently active workout (single record)\n            if (!database.objectStoreNames.contains(STORE_NAME)) {\n                database.createObjectStore(STORE_NAME, { keyPath: 'id' });\n            }\n\n            // Store for completed workouts (backup/history)\n            if (!database.objectStoreNames.contains(COMPLETED_STORE)) {\n                const completedStore = database.createObjectStore(COMPLETED_STORE, { keyPath: 'id' });\n                completedStore.createIndex('startTime', 'startTime', { unique: false });\n            }\n\n            // Store for raw debug data\n            if (!database.objectStoreNames.contains(DEBUG_STORE)) {\n                const debugStore = database.createObjectStore(DEBUG_STORE, { keyPath: 'id', autoIncrement: true });\n                debugStore.createIndex('timestamp', 'timestamp', { unique: false });\n                debugStore.createIndex('sensor', 'sensor', { unique: false });\n            }\n\n            // Store for PMC stats (client-side analytics)\n            if (!database.objectStoreNames.contains(PMC_STORE)) {\n                database.createObjectStore(PMC_STORE, { keyPath: 'date' });\n            }\n        };\n    });\n}\n\n/**\n * Daily PMC stats\n */\nexport interface DailyPMC {\n    date: string; // YYYY-MM-DD\n    tss: number;\n    ctl: number;\n    atl: number;\n    tsb: number;\n}\n\n/**\n * Get all PMC entries\n */\nexport async function getPMCData(): Promise<DailyPMC[]> {\n    const database = await openDatabase();\n    return new Promise((resolve, reject) => {\n        const transaction = database.transaction([PMC_STORE], 'readonly');\n        const store = transaction.objectStore(PMC_STORE);\n        // We want them ordered by date. Since key path is 'date', getAll should return sorted by key (string)\n        const request = store.getAll();\n\n        request.onsuccess = () => resolve(request.result || []);\n        request.onerror = () => reject(request.error);\n    });\n}\n\n/**\n * Clear all PMC entries\n */\nexport async function clearPMCData(): Promise<void> {\n    const database = await openDatabase();\n    return new Promise((resolve, reject) => {\n        const transaction = database.transaction([PMC_STORE], 'readwrite');\n        const store = transaction.objectStore(PMC_STORE);\n        const request = store.clear();\n\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n    });\n}\n\n/**\n * Save PMC entries (bulk upsert)\n */\nexport async function savePMCData(entries: DailyPMC[]): Promise<void> {\n    const database = await openDatabase();\n    return new Promise((resolve, reject) => {\n        const transaction = database.transaction([PMC_STORE], 'readwrite');\n        const store = transaction.objectStore(PMC_STORE);\n\n        // Handling multiple adds\n        let completed = 0;\n        let errors = 0;\n\n        if (entries.length === 0) {\n            resolve();\n            return;\n        }\n\n        entries.forEach((entry) => {\n            const request = store.put(entry);\n            request.onsuccess = () => {\n                completed++;\n                if (completed + errors === entries.length) {\n                    if (errors > 0) reject(new Error('Some entries failed to save'));\n                    else resolve();\n                }\n            };\n            request.onerror = () => {\n                errors++;\n                if (completed + errors === entries.length) reject(new Error('Entries failed to save'));\n            };\n        });\n\n        transaction.oncomplete = () => {\n            // Transaction completed\n            resolve();\n        };\n        transaction.onerror = () => reject(transaction.error);\n    });\n}\n\n/**\n * Save a raw debug log entry\n */\nexport async function saveDebugLog(sensor: string, data: string): Promise<void> {\n    try {\n        const database = await openDatabase();\n        const record: DebugLogEntry = {\n            timestamp: Date.now(),\n            sensor,\n            data,\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([DEBUG_STORE], 'readwrite');\n            const store = transaction.objectStore(DEBUG_STORE);\n            const request = store.add(record); // Using add since key is auto-increment\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not save debug log:', e);\n    }\n}\n\n/**\n * Get all debug logs\n */\nexport async function getDebugLogs(): Promise<DebugLogEntry[]> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([DEBUG_STORE], 'readonly');\n            const store = transaction.objectStore(DEBUG_STORE);\n            const index = store.index('timestamp');\n            const request = index.getAll();\n\n            request.onsuccess = () => resolve(request.result || []);\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not load debug logs:', e);\n        return [];\n    }\n}\n\n/**\n * Clear all debug logs\n */\nexport async function clearDebugLogs(): Promise<void> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([DEBUG_STORE], 'readwrite');\n            const store = transaction.objectStore(DEBUG_STORE);\n            const request = store.clear();\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not clear debug logs:', e);\n    }\n}\n\n/**\n * Saves the current workout state to IndexedDB\n */\nexport async function saveActiveWorkout(measurements: MeasurementsData, startTime: number | null): Promise<void> {\n    try {\n        const database = await openDatabase();\n\n        const record: ActiveWorkoutRecord = {\n            id: 'current',\n            startTime: startTime ?? Date.now(),\n            lastUpdated: Date.now(),\n            heartrate: measurements.heartrate,\n            power: measurements.power,\n            cadence: measurements.cadence,\n            speed: measurements.speed,\n            distance: measurements.distance,\n            altitude: measurements.altitude,\n            gps: measurements.gps,\n            treadmill: measurements.treadmill || [],\n            laps: measurements.laps || [],\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([STORE_NAME], 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.put(record);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not save active workout:', e);\n    }\n}\n\n/**\n * Clear the active workout from storage\n */\nexport async function clearActiveWorkout(): Promise<void> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([STORE_NAME], 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.delete('current');\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not clear active workout:', e);\n    }\n}\n\n/**\n * Load the active workout from storage\n */\nexport async function loadActiveWorkout(): Promise<ActiveWorkoutRecord | null> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([STORE_NAME], 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.get('current');\n\n            request.onsuccess = () => {\n                if (request.result) {\n                    // Normalize optional arrays if missing in older DB versions\n                    const record = request.result;\n                    if (!record.treadmill) record.treadmill = [];\n                    if (!record.laps) record.laps = [];\n                    resolve(record);\n                } else {\n                    resolve(null);\n                }\n            };\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not load active workout:', e);\n        return null;\n    }\n}\n\n/**\n * Check storage quota and warn if high\n */\nexport async function checkStorageQuota(): Promise<void> {\n    if (navigator.storage && navigator.storage.estimate) {\n        try {\n            const estimate = await navigator.storage.estimate();\n            if (estimate.quota && estimate.usage) {\n                const percent = (estimate.usage / estimate.quota) * 100;\n                if (percent > 80) {\n                    // Using alert for visibility as requested, though custom toast would be better in production\n                    alert(\n                        ` Storage Warning: You have used ${percent.toFixed(1)}% of available storage. Please export and delete old workouts.`\n                    );\n                }\n            }\n        } catch (e) {\n            console.warn('Storage estimate failed', e);\n        }\n    }\n}\n\n/**\n * Save a completed workout to history\n */\nexport async function saveCompletedWorkout(\n    measurements: MeasurementsData,\n    startTime: number,\n    endTime: number,\n    summary?: any\n): Promise<string> {\n    await checkStorageQuota();\n\n    const id = `workout_${startTime}`;\n\n    try {\n        const database = await openDatabase();\n\n        const record: StoredWorkout = {\n            id,\n            startTime,\n            lastUpdated: endTime,\n            isCompleted: true,\n            // Deep clone to remove any non-serializable data (functions, etc.)\n            measurements: JSON.parse(JSON.stringify(measurements)),\n            synced: false,\n            // Deep clone summary to ensure it's serializable (remove functions)\n            summary: summary ? JSON.parse(JSON.stringify(summary)) : undefined,\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([COMPLETED_STORE], 'readwrite');\n            const store = transaction.objectStore(COMPLETED_STORE);\n            const request = store.put(record);\n\n            request.onsuccess = () => {\n                resolve(id);\n\n                // Update streak and check achievements after successful save\n                // Do this async without blocking the save\n                updateStreakAndAchievements(startTime).catch(err => {\n                    console.warn('Failed to update streak/achievements:', err);\n                });\n            };\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.error('Failed to save completed workout:', e);\n        throw e;\n    }\n}\n\n/**\n * Update streak and check for new achievements\n * Called after saving a workout\n */\nasync function updateStreakAndAchievements(workoutDate: number): Promise<void> {\n    try {\n        // Dynamically import to avoid circular dependencies\n        const { goalsStore } = await import('../state/GoalsStore.js');\n        const { checkAndNotifyAchievements } = await import('../ui/achievementNotification.js');\n\n        // Update streak\n        await goalsStore.updateStreak(workoutDate);\n\n        // Check and notify for new achievements\n        await checkAndNotifyAchievements();\n    } catch (error) {\n        console.error('Error in updateStreakAndAchievements:', error);\n    }\n}\n\n/**\n * Get all completed workouts from history\n */\nexport async function getWorkoutHistory(): Promise<StoredWorkout[]> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([COMPLETED_STORE], 'readonly');\n            const store = transaction.objectStore(COMPLETED_STORE);\n            const index = store.index('startTime');\n            // Get all, sorted by start time (newest first requires manual reverse or cursor)\n            const request = index.getAll();\n\n            request.onsuccess = () => {\n                // Return newest first\n                resolve((request.result || []).reverse());\n            };\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not load workout history:', e);\n        return [];\n    }\n}\n\n// Throttled save mechanism\nlet saveTimeout: ReturnType<typeof setTimeout> | null = null;\nlet pendingSave: { measurements: MeasurementsData; startTime: number | null } | null = null;\n\n// Allow a 3rd optional parameter for delay to satisfy legacy tests, even if ignored or treated differently\nexport const throttledSave = (measurements: MeasurementsData, startTime: number | null, delayMs?: number): void => {\n    pendingSave = { measurements, startTime };\n    if (!saveTimeout) {\n        saveTimeout = setTimeout(async () => {\n            if (pendingSave) {\n                await saveActiveWorkout(pendingSave.measurements, pendingSave.startTime);\n                pendingSave = null;\n            }\n            saveTimeout = null;\n        }, delayMs || 2000); // Use provided delay or default 2s\n    }\n};\n\nexport const flushPendingSave = async (): Promise<void> => {\n    if (saveTimeout) {\n        clearTimeout(saveTimeout);\n        saveTimeout = null;\n    }\n    if (pendingSave) {\n        await saveActiveWorkout(pendingSave.measurements, pendingSave.startTime);\n        pendingSave = null;\n    }\n};\n\nexport const isIndexedDBSupported = (): boolean => {\n    return typeof window !== 'undefined' && 'indexedDB' in window;\n};\n\n/**\n * Legacy API Support / Aliases\n */\n\nimport { calculateWorkoutSummary } from '../calculations/summary.js';\nimport { settingsStore } from '../state/SettingsStore.js';\n\nexport const archiveWorkout = async (): Promise<string | null> => {\n    // Ensure any pending throttled saves are written to DB first\n    await flushPendingSave();\n\n    const active = await loadActiveWorkout();\n    if (!active) return null;\n\n    // Calculate full summary (including NP, IF, TSS)\n    const toMeasurement = (arr: any[] | undefined) =>\n        (arr || []).map((p) => (typeof p === 'number' ? { value: p } : { value: p.value }));\n\n    // Calculate summary using shared logic\n    let summary: any;\n    const settings = settingsStore.getAll();\n    summary = calculateWorkoutSummary(\n        active.startTime,\n        active.lastUpdated,\n        {\n            power: toMeasurement(active.power),\n            heartrate: toMeasurement(active.heartrate),\n            cadence: toMeasurement(active.cadence),\n        },\n        undefined,\n        settings.weight\n    );\n\n    await saveCompletedWorkout(\n        {\n            heartrate: active.heartrate,\n            power: active.power,\n            cadence: active.cadence,\n            speed: active.speed,\n            distance: active.distance,\n            altitude: active.altitude,\n            gps: active.gps,\n            treadmill: active.treadmill,\n            laps: active.laps,\n        },\n        active.startTime,\n        active.lastUpdated,\n        summary\n    );\n\n    // Now update PMC if we have TSS\n    if (summary.trainingLoad > 0) {\n        try {\n            const { addWorkoutToPMC } = await import('../services/fitnessService.js');\n            await addWorkoutToPMC(new Date(active.startTime), summary.trainingLoad);\n        } catch (e) {\n            console.error('Failed to update PMC:', e);\n        }\n    }\n\n    await clearActiveWorkout();\n    return `workout_${active.startTime}`;\n};\n\nexport const hasRecoverableWorkout = async (): Promise<boolean> => {\n    const active = await loadActiveWorkout();\n    return !!active;\n};\n\nexport const getCompletedWorkouts = getWorkoutHistory; // Alias\n\nexport const markWorkoutSynced = async (id: string): Promise<void> => {\n    const db = await openDatabase();\n    return new Promise((resolve, reject) => {\n        const tx = db.transaction(COMPLETED_STORE, 'readwrite');\n        const store = tx.objectStore(COMPLETED_STORE);\n        const request = store.get(id);\n\n        request.onsuccess = () => {\n            const data = request.result as StoredWorkout;\n            if (data) {\n                data.synced = true;\n                data.syncedTime = Date.now();\n                store.put(data);\n                resolve();\n            } else {\n                reject(new Error('Workout not found'));\n            }\n        };\n        request.onerror = () => reject(request.error);\n    });\n};\n\n/**\n * Get a specific completed workout by ID\n */\nexport async function getCompletedWorkout(id: string): Promise<StoredWorkout | undefined> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([COMPLETED_STORE], 'readonly');\n            const store = transaction.objectStore(COMPLETED_STORE);\n            const request = store.get(id);\n\n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not load workout:', e);\n        return undefined;\n    }\n}\n\n/**\n * Delete a completed workout by ID\n */\nexport async function deleteCompletedWorkout(id: string): Promise<void> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([COMPLETED_STORE], 'readwrite');\n            const store = transaction.objectStore(COMPLETED_STORE);\n            const request = store.delete(id);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not delete workout:', e);\n        throw e;\n    }\n}\n","/*! Capacitor: https://capacitorjs.com/ - MIT License */\nvar ExceptionCode;\n(function (ExceptionCode) {\n    /**\n     * API is not implemented.\n     *\n     * This usually means the API can't be used because it is not implemented for\n     * the current platform.\n     */\n    ExceptionCode[\"Unimplemented\"] = \"UNIMPLEMENTED\";\n    /**\n     * API is not available.\n     *\n     * This means the API can't be used right now because:\n     *   - it is currently missing a prerequisite, such as network connectivity\n     *   - it requires a particular platform or browser version\n     */\n    ExceptionCode[\"Unavailable\"] = \"UNAVAILABLE\";\n})(ExceptionCode || (ExceptionCode = {}));\nclass CapacitorException extends Error {\n    constructor(message, code, data) {\n        super(message);\n        this.message = message;\n        this.code = code;\n        this.data = data;\n    }\n}\nconst getPlatformId = (win) => {\n    var _a, _b;\n    if (win === null || win === void 0 ? void 0 : win.androidBridge) {\n        return 'android';\n    }\n    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {\n        return 'ios';\n    }\n    else {\n        return 'web';\n    }\n};\n\nconst createCapacitor = (win) => {\n    const capCustomPlatform = win.CapacitorCustomPlatform || null;\n    const cap = win.Capacitor || {};\n    const Plugins = (cap.Plugins = cap.Plugins || {});\n    const getPlatform = () => {\n        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);\n    };\n    const isNativePlatform = () => getPlatform() !== 'web';\n    const isPluginAvailable = (pluginName) => {\n        const plugin = registeredPlugins.get(pluginName);\n        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {\n            // JS implementation available for the current platform.\n            return true;\n        }\n        if (getPluginHeader(pluginName)) {\n            // Native implementation available.\n            return true;\n        }\n        return false;\n    };\n    const getPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName); };\n    const handleError = (err) => win.console.error(err);\n    const registeredPlugins = new Map();\n    const registerPlugin = (pluginName, jsImplementations = {}) => {\n        const registeredPlugin = registeredPlugins.get(pluginName);\n        if (registeredPlugin) {\n            console.warn(`Capacitor plugin \"${pluginName}\" already registered. Cannot register plugins twice.`);\n            return registeredPlugin.proxy;\n        }\n        const platform = getPlatform();\n        const pluginHeader = getPluginHeader(pluginName);\n        let jsImplementation;\n        const loadPluginImplementation = async () => {\n            if (!jsImplementation && platform in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations[platform] === 'function'\n                        ? (jsImplementation = await jsImplementations[platform]())\n                        : (jsImplementation = jsImplementations[platform]);\n            }\n            else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations['web'] === 'function'\n                        ? (jsImplementation = await jsImplementations['web']())\n                        : (jsImplementation = jsImplementations['web']);\n            }\n            return jsImplementation;\n        };\n        const createPluginMethod = (impl, prop) => {\n            var _a, _b;\n            if (pluginHeader) {\n                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);\n                if (methodHeader) {\n                    if (methodHeader.rtype === 'promise') {\n                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);\n                    }\n                    else {\n                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);\n                    }\n                }\n                else if (impl) {\n                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);\n                }\n            }\n            else if (impl) {\n                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);\n            }\n            else {\n                throw new CapacitorException(`\"${pluginName}\" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n            }\n        };\n        const createPluginMethodWrapper = (prop) => {\n            let remove;\n            const wrapper = (...args) => {\n                const p = loadPluginImplementation().then((impl) => {\n                    const fn = createPluginMethod(impl, prop);\n                    if (fn) {\n                        const p = fn(...args);\n                        remove = p === null || p === void 0 ? void 0 : p.remove;\n                        return p;\n                    }\n                    else {\n                        throw new CapacitorException(`\"${pluginName}.${prop}()\" is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n                    }\n                });\n                if (prop === 'addListener') {\n                    p.remove = async () => remove();\n                }\n                return p;\n            };\n            // Some flair \n            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;\n            Object.defineProperty(wrapper, 'name', {\n                value: prop,\n                writable: false,\n                configurable: false,\n            });\n            return wrapper;\n        };\n        const addListener = createPluginMethodWrapper('addListener');\n        const removeListener = createPluginMethodWrapper('removeListener');\n        const addListenerNative = (eventName, callback) => {\n            const call = addListener({ eventName }, callback);\n            const remove = async () => {\n                const callbackId = await call;\n                removeListener({\n                    eventName,\n                    callbackId,\n                }, callback);\n            };\n            const p = new Promise((resolve) => call.then(() => resolve({ remove })));\n            p.remove = async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            };\n            return p;\n        };\n        const proxy = new Proxy({}, {\n            get(_, prop) {\n                switch (prop) {\n                    // https://github.com/facebook/react/issues/20030\n                    case '$$typeof':\n                        return undefined;\n                    case 'toJSON':\n                        return () => ({});\n                    case 'addListener':\n                        return pluginHeader ? addListenerNative : addListener;\n                    case 'removeListener':\n                        return removeListener;\n                    default:\n                        return createPluginMethodWrapper(prop);\n                }\n            },\n        });\n        Plugins[pluginName] = proxy;\n        registeredPlugins.set(pluginName, {\n            name: pluginName,\n            proxy,\n            platforms: new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])]),\n        });\n        return proxy;\n    };\n    // Add in convertFileSrc for web, it will already be available in native context\n    if (!cap.convertFileSrc) {\n        cap.convertFileSrc = (filePath) => filePath;\n    }\n    cap.getPlatform = getPlatform;\n    cap.handleError = handleError;\n    cap.isNativePlatform = isNativePlatform;\n    cap.isPluginAvailable = isPluginAvailable;\n    cap.registerPlugin = registerPlugin;\n    cap.Exception = CapacitorException;\n    cap.DEBUG = !!cap.DEBUG;\n    cap.isLoggingEnabled = !!cap.isLoggingEnabled;\n    return cap;\n};\nconst initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));\n\nconst Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof global !== 'undefined'\n                ? global\n                : {});\nconst registerPlugin = Capacitor.registerPlugin;\n\n/**\n * Base class web plugins should extend.\n */\nclass WebPlugin {\n    constructor() {\n        this.listeners = {};\n        this.retainedEventArguments = {};\n        this.windowListeners = {};\n    }\n    addListener(eventName, listenerFunc) {\n        let firstListener = false;\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            this.listeners[eventName] = [];\n            firstListener = true;\n        }\n        this.listeners[eventName].push(listenerFunc);\n        // If we haven't added a window listener for this event and it requires one,\n        // go ahead and add it\n        const windowListener = this.windowListeners[eventName];\n        if (windowListener && !windowListener.registered) {\n            this.addWindowListener(windowListener);\n        }\n        if (firstListener) {\n            this.sendRetainedArgumentsForEvent(eventName);\n        }\n        const remove = async () => this.removeListener(eventName, listenerFunc);\n        const p = Promise.resolve({ remove });\n        return p;\n    }\n    async removeAllListeners() {\n        this.listeners = {};\n        for (const listener in this.windowListeners) {\n            this.removeWindowListener(this.windowListeners[listener]);\n        }\n        this.windowListeners = {};\n    }\n    notifyListeners(eventName, data, retainUntilConsumed) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            if (retainUntilConsumed) {\n                let args = this.retainedEventArguments[eventName];\n                if (!args) {\n                    args = [];\n                }\n                args.push(data);\n                this.retainedEventArguments[eventName] = args;\n            }\n            return;\n        }\n        listeners.forEach((listener) => listener(data));\n    }\n    hasListeners(eventName) {\n        var _a;\n        return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);\n    }\n    registerWindowListener(windowEventName, pluginEventName) {\n        this.windowListeners[pluginEventName] = {\n            registered: false,\n            windowEventName,\n            pluginEventName,\n            handler: (event) => {\n                this.notifyListeners(pluginEventName, event);\n            },\n        };\n    }\n    unimplemented(msg = 'not implemented') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);\n    }\n    unavailable(msg = 'not available') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);\n    }\n    async removeListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(listenerFunc);\n        this.listeners[eventName].splice(index, 1);\n        // If there are no more listeners for this type of event,\n        // remove the window listener\n        if (!this.listeners[eventName].length) {\n            this.removeWindowListener(this.windowListeners[eventName]);\n        }\n    }\n    addWindowListener(handle) {\n        window.addEventListener(handle.windowEventName, handle.handler);\n        handle.registered = true;\n    }\n    removeWindowListener(handle) {\n        if (!handle) {\n            return;\n        }\n        window.removeEventListener(handle.windowEventName, handle.handler);\n        handle.registered = false;\n    }\n    sendRetainedArgumentsForEvent(eventName) {\n        const args = this.retainedEventArguments[eventName];\n        if (!args) {\n            return;\n        }\n        delete this.retainedEventArguments[eventName];\n        args.forEach((arg) => {\n            this.notifyListeners(eventName, arg);\n        });\n    }\n}\n\nconst WebView = /*#__PURE__*/ registerPlugin('WebView');\n/******** END WEB VIEW PLUGIN ********/\n/******** COOKIES PLUGIN ********/\n/**\n * Safely web encode a string value (inspired by js-cookie)\n * @param str The string value to encode\n */\nconst encode = (str) => encodeURIComponent(str)\n    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n    .replace(/[()]/g, escape);\n/**\n * Safely web decode a string value (inspired by js-cookie)\n * @param str The string value to decode\n */\nconst decode = (str) => str.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\nclass CapacitorCookiesPluginWeb extends WebPlugin {\n    async getCookies() {\n        const cookies = document.cookie;\n        const cookieMap = {};\n        cookies.split(';').forEach((cookie) => {\n            if (cookie.length <= 0)\n                return;\n            // Replace first \"=\" with CAP_COOKIE to prevent splitting on additional \"=\"\n            let [key, value] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');\n            key = decode(key).trim();\n            value = decode(value).trim();\n            cookieMap[key] = value;\n        });\n        return cookieMap;\n    }\n    async setCookie(options) {\n        try {\n            // Safely Encoded Key/Value\n            const encodedKey = encode(options.key);\n            const encodedValue = encode(options.value);\n            // Clean & sanitize options\n            const expires = `; expires=${(options.expires || '').replace('expires=', '')}`; // Default is \"; expires=\"\n            const path = (options.path || '/').replace('path=', ''); // Default is \"path=/\"\n            const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : '';\n            document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}; ${domain};`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async deleteCookie(options) {\n        try {\n            document.cookie = `${options.key}=; Max-Age=0`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearCookies() {\n        try {\n            const cookies = document.cookie.split(';') || [];\n            for (const cookie of cookies) {\n                document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);\n            }\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearAllCookies() {\n        try {\n            await this.clearCookies();\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n}\nconst CapacitorCookies = registerPlugin('CapacitorCookies', {\n    web: () => new CapacitorCookiesPluginWeb(),\n});\n// UTILITY FUNCTIONS\n/**\n * Read in a Blob value and return it as a base64 string\n * @param blob The blob value to convert to a base64 string\n */\nconst readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n        const base64String = reader.result;\n        // remove prefix \"data:application/pdf;base64,\"\n        resolve(base64String.indexOf(',') >= 0 ? base64String.split(',')[1] : base64String);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(blob);\n});\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\nconst normalizeHttpHeaders = (headers = {}) => {\n    const originalKeys = Object.keys(headers);\n    const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());\n    const normalized = loweredKeys.reduce((acc, key, index) => {\n        acc[key] = headers[originalKeys[index]];\n        return acc;\n    }, {});\n    return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\nconst buildUrlParams = (params, shouldEncode = true) => {\n    if (!params)\n        return null;\n    const output = Object.entries(params).reduce((accumulator, entry) => {\n        const [key, value] = entry;\n        let encodedValue;\n        let item;\n        if (Array.isArray(value)) {\n            item = '';\n            value.forEach((str) => {\n                encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n                item += `${key}=${encodedValue}&`;\n            });\n            // last character will always be \"&\" so slice it off\n            item.slice(0, -1);\n        }\n        else {\n            encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n            item = `${key}=${encodedValue}`;\n        }\n        return `${accumulator}&${item}`;\n    }, '');\n    // Remove initial \"&\" from the reduce\n    return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\nconst buildRequestInit = (options, extra = {}) => {\n    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);\n    // Get the content-type\n    const headers = normalizeHttpHeaders(options.headers);\n    const type = headers['content-type'] || '';\n    // If body is already a string, then pass it through as-is.\n    if (typeof options.data === 'string') {\n        output.body = options.data;\n    }\n    // Build request initializers based off of content-type\n    else if (type.includes('application/x-www-form-urlencoded')) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(options.data || {})) {\n            params.set(key, value);\n        }\n        output.body = params.toString();\n    }\n    else if (type.includes('multipart/form-data') || options.data instanceof FormData) {\n        const form = new FormData();\n        if (options.data instanceof FormData) {\n            options.data.forEach((value, key) => {\n                form.append(key, value);\n            });\n        }\n        else {\n            for (const key of Object.keys(options.data)) {\n                form.append(key, options.data[key]);\n            }\n        }\n        output.body = form;\n        const headers = new Headers(output.headers);\n        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n        output.headers = headers;\n    }\n    else if (type.includes('application/json') || typeof options.data === 'object') {\n        output.body = JSON.stringify(options.data);\n    }\n    return output;\n};\n// WEB IMPLEMENTATION\nclass CapacitorHttpPluginWeb extends WebPlugin {\n    /**\n     * Perform an Http request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async request(options) {\n        const requestInit = buildRequestInit(options, options.webFetchExtra);\n        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n        const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n        const response = await fetch(url, requestInit);\n        const contentType = response.headers.get('content-type') || '';\n        // Default to 'text' responseType so no parsing happens\n        let { responseType = 'text' } = response.ok ? options : {};\n        // If the response content-type is json, force the response to be json\n        if (contentType.includes('application/json')) {\n            responseType = 'json';\n        }\n        let data;\n        let blob;\n        switch (responseType) {\n            case 'arraybuffer':\n            case 'blob':\n                blob = await response.blob();\n                data = await readBlobAsBase64(blob);\n                break;\n            case 'json':\n                data = await response.json();\n                break;\n            case 'document':\n            case 'text':\n            default:\n                data = await response.text();\n        }\n        // Convert fetch headers to Capacitor HttpHeaders\n        const headers = {};\n        response.headers.forEach((value, key) => {\n            headers[key] = value;\n        });\n        return {\n            data,\n            headers,\n            status: response.status,\n            url: response.url,\n        };\n    }\n    /**\n     * Perform an Http GET request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async get(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'GET' }));\n    }\n    /**\n     * Perform an Http POST request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async post(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'POST' }));\n    }\n    /**\n     * Perform an Http PUT request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async put(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PUT' }));\n    }\n    /**\n     * Perform an Http PATCH request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async patch(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));\n    }\n    /**\n     * Perform an Http DELETE request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async delete(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));\n    }\n}\nconst CapacitorHttp = registerPlugin('CapacitorHttp', {\n    web: () => new CapacitorHttpPluginWeb(),\n});\n/******** END HTTP PLUGIN ********/\n/******** SYSTEM BARS PLUGIN ********/\n/**\n * Available status bar styles.\n */\nvar SystemBarsStyle;\n(function (SystemBarsStyle) {\n    /**\n     * Light system bar content on a dark background.\n     *\n     * @since 8.0.0\n     */\n    SystemBarsStyle[\"Dark\"] = \"DARK\";\n    /**\n     * For dark system bar content on a light background.\n     *\n     * @since 8.0.0\n     */\n    SystemBarsStyle[\"Light\"] = \"LIGHT\";\n    /**\n     * The style is based on the device appearance or the underlying content.\n     * If the device is using Dark mode, the system bars content will be light.\n     * If the device is using Light mode, the system bars content will be dark.\n     *\n     * @since 8.0.0\n     */\n    SystemBarsStyle[\"Default\"] = \"DEFAULT\";\n})(SystemBarsStyle || (SystemBarsStyle = {}));\n/**\n * Available system bar types.\n */\nvar SystemBarType;\n(function (SystemBarType) {\n    /**\n     * The top status bar on both Android and iOS.\n     *\n     * @since 8.0.0\n     */\n    SystemBarType[\"StatusBar\"] = \"StatusBar\";\n    /**\n     * The navigation bar (or gesture bar on iOS) on both Android and iOS.\n     *\n     * @since 8.0.0\n     */\n    SystemBarType[\"NavigationBar\"] = \"NavigationBar\";\n})(SystemBarType || (SystemBarType = {}));\nclass SystemBarsPluginWeb extends WebPlugin {\n    async setStyle() {\n        this.unavailable('not available for web');\n    }\n    async setAnimation() {\n        this.unavailable('not available for web');\n    }\n    async show() {\n        this.unavailable('not available for web');\n    }\n    async hide() {\n        this.unavailable('not available for web');\n    }\n}\nconst SystemBars = registerPlugin('SystemBars', {\n    web: () => new SystemBarsPluginWeb(),\n});\n/******** END SYSTEM BARS PLUGIN ********/\n\nexport { Capacitor, CapacitorCookies, CapacitorException, CapacitorHttp, ExceptionCode, SystemBarType, SystemBars, SystemBarsStyle, WebPlugin, WebView, buildRequestInit, registerPlugin };\n//# sourceMappingURL=index.js.map\n","/**\n * Application Settings Configuration\n *\n * Manages data structure and persistence only.\n * UI logic is in ui/settings.ts.\n */\n\n/**\n * Auto-pause source metric options\n */\nexport type AutoPauseSource = 'speed' | 'power' | 'cadence';\n\n/**\n * Auto-pause settings\n */\nexport interface AutoPauseSettings {\n    /** Whether auto-pause is enabled */\n    enabled: boolean;\n    /** Which metric to monitor for auto-pause */\n    source: AutoPauseSource;\n    /** Threshold value below which to pause (in source units: km/h, watts, rpm) */\n    threshold: number;\n    /** Delay in seconds before pausing (debounce) */\n    delay: number;\n}\n\n/**\n * Workout metadata settings - controls post-workout prompts\n */\nexport interface WorkoutMetadataSettings {\n    /** Whether to prompt for workout title/notes after completion */\n    promptForNotes: boolean;\n    /** Whether to prompt for perceived exertion (RPE) after completion */\n    promptForExertion: boolean;\n}\n\n/**\n * Countdown settings - controls pre-workout countdown\n */\nexport interface CountdownSettings {\n    /** Countdown duration in seconds (0 = disabled, 3, 5, or 10) */\n    duration: 0 | 3 | 5 | 10;\n    /** Whether to play audio beep during countdown */\n    enableBeep: boolean;\n    /** Whether to use voice announcement during countdown */\n    enableVoice: boolean;\n}\n\n/**\n * Auto-lap trigger source\n */\nexport type AutoLapSource = 'distance' | 'time';\n\n/**\n * Auto-lap settings\n */\nexport interface AutoLapSettings {\n    /** Whether auto-lap is enabled */\n    enabled: boolean;\n    /** What triggers auto-lap */\n    source: AutoLapSource;\n    /** Distance interval in km (for distance-based auto-lap) */\n    distanceKm: number;\n    /** Time interval in minutes (for time-based auto-lap) */\n    timeMinutes: number;\n}\n\n/**\n * Metrics to include in voice announcements\n */\nexport interface VoiceAnnouncementMetrics {\n    /** Announce current power */\n    power: boolean;\n    /** Announce heart rate */\n    heartrate: boolean;\n    /** Announce cadence */\n    cadence: boolean;\n    /** Announce current speed */\n    speed: boolean;\n    /** Announce total distance */\n    distance: boolean;\n    /** Announce elapsed time */\n    time: boolean;\n    /** Announce current pace (for running) */\n    pace: boolean;\n}\n\n/**\n * Enhanced voice announcement settings\n */\nexport interface EnhancedVoiceSettings {\n    /** Time-based announcement interval in minutes (0 = disabled) */\n    timeIntervalMinutes: 0 | 1 | 5 | 10 | 15 | 30;\n    /** Distance-based announcement interval in km (0 = disabled) */\n    distanceIntervalKm: 0 | 1 | 5 | 10;\n    /** Which metrics to announce */\n    metrics: VoiceAnnouncementMetrics;\n    /** Speech rate (0.5 = slow, 1 = normal, 1.5 = fast, 2 = very fast) */\n    speechRate: 0.5 | 0.75 | 1 | 1.25 | 1.5 | 2;\n    /** Specific voice to use (URI) or null for default */\n    voiceURI: string | null;\n    /** Whether to announce power target feedback (e.g. \"10 watts low\") */\n    workoutTargetFeedback: boolean;\n    /** Custom template for announcements (e.g., \"Power {power}, HR {heartrate}\"). If null/empty, uses default metrics. */\n    announcementTemplate: string | null;\n    /** Enable smart context-aware announcements (verbosity based on effort, frequency based on intervals) */\n    smartAnnouncements: boolean;\n}\n\n/**\n * Intervals.icu integration settings\n */\nexport interface IntervalsSettings {\n    /** Whether integration is enabled */\n    enabled: boolean;\n    /** API Key (get from intervals.icu settings) */\n    apiKey: string;\n    /** Athlete ID (use 'i' for self) */\n    athleteId: string;\n    /** Whether to upload automatically after workout */\n    autoUpload: boolean;\n}\n\n/**\n * Music style preset options\n */\nexport type MusicStyle = 'electronic' | 'ambient' | 'rock' | 'minimal';\n\n/**\n * Tempo synchronization mode\n */\nexport type TempoSync = 'cadence' | 'fixed' | 'adaptive';\n\n/**\n * Intensity mapping source\n */\nexport type IntensityMapping = 'power' | 'heartrate' | 'manual';\n\n/**\n * Transition speed for layer changes\n */\nexport type TransitionSpeed = 'instant' | 'smooth' | 'gradual';\n\n/**\n * Music generation settings\n */\nexport interface MusicSettings {\n    /** Whether music generation is enabled */\n    enabled: boolean;\n    /** Master music volume (0-1) */\n    volume: number;\n    /** Music style preset */\n    style: MusicStyle;\n    /** How tempo is determined */\n    tempoSync: TempoSync;\n    /** Fixed BPM when tempoSync is 'fixed' */\n    fixedBPM: number;\n    /** What metric drives intensity changes */\n    intensityMapping: IntensityMapping;\n    /** Speed of layer transitions */\n    transitionSpeed: TransitionSpeed;\n    /** Whether to duck music volume during voice announcements */\n    duckingEnabled: boolean;\n    /** How much to reduce volume when ducking (0-1) */\n    duckingLevel: number;\n}\n\n/**\n * Application settings\n */\nexport interface AppSettings {\n    // Activity type setting\n    sportType: 'cycling' | 'running' | 'indoor' | 'walking';\n\n    // Dashboard display settings\n    power: boolean;\n    cadence: boolean;\n    heartrate: boolean;\n    speed: boolean;\n    distance: boolean;\n    altitude: boolean;\n    treadmillSpeed: boolean;\n    power3s: boolean;\n\n    // Accessibility settings\n    highContrast: boolean;\n    colorblindPatterns: boolean;\n\n    // Voice Feedback settings\n    voiceEnabled: boolean;\n    voiceLaps: boolean;\n    voiceZones: boolean;\n\n    // Export format settings\n    exportTcx: boolean;\n    exportCsv: boolean;\n    exportJson: boolean;\n    exportFit: boolean;\n\n    // Auto-pause settings\n    autoPause: AutoPauseSettings;\n\n    // Workout metadata settings\n    workoutMetadata: WorkoutMetadataSettings;\n\n    // Countdown settings\n    countdown: CountdownSettings;\n\n    // Auto-lap settings\n    autoLap: AutoLapSettings;\n\n    // Enhanced voice announcement settings\n    enhancedVoice: EnhancedVoiceSettings;\n\n    // Intervals.icu integration settings\n    intervals: IntervalsSettings;\n\n    // Music generation settings\n    music: MusicSettings;\n\n    // Calorie estimation settings\n    weightKg: number;\n    showCalories: boolean;\n\n    // Debug settings\n    debugMode: boolean;\n\n    // Mock sensors for demo/testing\n    mockSensors: boolean;\n\n    // Wheel circumference for speed sensors (mm)\n    wheelCircumferenceMm: number;\n}\n\n/** Storage key for settings */\nexport const SETTINGS_KEY = 'bpt-settings';\n\n/** Default auto-pause settings */\nexport const defaultAutoPauseSettings: AutoPauseSettings = {\n    enabled: false,\n    source: 'speed',\n    threshold: 3, // 3 km/h default\n    delay: 3, // 3 seconds delay before pausing\n};\n\n/** Default workout metadata settings */\nexport const defaultWorkoutMetadataSettings: WorkoutMetadataSettings = {\n    promptForNotes: true,\n    promptForExertion: true,\n};\n\n/** Default countdown settings */\nexport const defaultCountdownSettings: CountdownSettings = {\n    duration: 0, // Disabled by default\n    enableBeep: true,\n    enableVoice: false,\n};\n\n/** Default auto-lap settings */\nexport const defaultAutoLapSettings: AutoLapSettings = {\n    enabled: false,\n    source: 'distance',\n    distanceKm: 1, // 1 km default\n    timeMinutes: 5, // 5 minutes default\n};\n\n/** Default voice announcement metrics */\nexport const defaultVoiceMetrics: VoiceAnnouncementMetrics = {\n    power: true,\n    heartrate: true,\n    cadence: false,\n    speed: true,\n    distance: true,\n    time: true,\n    pace: false,\n};\n\n/** Default enhanced voice settings */\nexport const defaultEnhancedVoiceSettings: EnhancedVoiceSettings = {\n    timeIntervalMinutes: 0, // Disabled by default\n    distanceIntervalKm: 0, // Disabled by default\n    metrics: { ...defaultVoiceMetrics },\n    speechRate: 1,\n    voiceURI: null,\n    workoutTargetFeedback: false,\n    announcementTemplate: null,\n    smartAnnouncements: false,\n};\n\n/** Default Intervals.icu settings */\nexport const defaultIntervalsSettings: IntervalsSettings = {\n    enabled: false,\n    apiKey: '',\n    athleteId: 'i',\n    autoUpload: false,\n};\n\n/** Default music generation settings */\nexport const defaultMusicSettings: MusicSettings = {\n    enabled: false,\n    volume: 0.6,\n    style: 'electronic',\n    tempoSync: 'cadence',\n    fixedBPM: 120,\n    intensityMapping: 'power',\n    transitionSpeed: 'smooth',\n    duckingEnabled: true,\n    duckingLevel: 0.2,\n};\n\n/** Default settings */\nexport const defaultSettings: AppSettings = {\n    sportType: 'cycling',\n    power: true,\n    cadence: true,\n    heartrate: true,\n    speed: true,\n    distance: true,\n    altitude: true,\n    treadmillSpeed: false,\n    power3s: false,\n    highContrast: false,\n    colorblindPatterns: false,\n    voiceEnabled: false,\n    voiceLaps: true,\n    voiceZones: true,\n    exportTcx: true,\n    exportCsv: true,\n    exportJson: false,\n    exportFit: false,\n    autoPause: { ...defaultAutoPauseSettings },\n    workoutMetadata: { ...defaultWorkoutMetadataSettings },\n    countdown: { ...defaultCountdownSettings },\n    autoLap: { ...defaultAutoLapSettings },\n    enhancedVoice: { ...defaultEnhancedVoiceSettings },\n    intervals: { ...defaultIntervalsSettings },\n    music: { ...defaultMusicSettings },\n    weightKg: 75,\n    showCalories: false,\n    debugMode: false,\n    mockSensors: false,\n    wheelCircumferenceMm: 2096, // Default: 700x25c road bike wheel\n};\n\n/**\n * Get current settings from localStorage\n */\nexport function getSettings(): AppSettings {\n    const settingsJson = localStorage.getItem(SETTINGS_KEY);\n    if (settingsJson) {\n        const parsed = JSON.parse(settingsJson);\n        // Ensure all nested settings have all required fields (migration for existing users)\n        return {\n            ...defaultSettings,\n            ...parsed,\n            autoPause: {\n                ...defaultAutoPauseSettings,\n                ...(parsed.autoPause || {}),\n            },\n            workoutMetadata: {\n                ...defaultWorkoutMetadataSettings,\n                ...(parsed.workoutMetadata || {}),\n            },\n            countdown: {\n                ...defaultCountdownSettings,\n                ...(parsed.countdown || {}),\n            },\n            autoLap: {\n                ...defaultAutoLapSettings,\n                ...(parsed.autoLap || {}),\n            },\n            enhancedVoice: {\n                ...defaultEnhancedVoiceSettings,\n                ...(parsed.enhancedVoice || {}),\n                metrics: {\n                    ...defaultVoiceMetrics,\n                    ...(parsed.enhancedVoice?.metrics || {}),\n                },\n            },\n            intervals: {\n                ...defaultIntervalsSettings,\n                ...(parsed.intervals || {}),\n            },\n            music: {\n                ...defaultMusicSettings,\n                ...(parsed.music || {}),\n            },\n            weightKg: parsed.weightKg ?? 75,\n            showCalories: parsed.showCalories ?? false,\n        };\n    }\n    return { ...defaultSettings };\n}\n\n/**\n * Save settings to localStorage\n */\nexport function saveSettingsToStorage(settings: AppSettings): void {\n    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));\n    // Dispatch event so UI can react if needed (though UI usually initiates the save)\n    window.dispatchEvent(new CustomEvent('settings-changed'));\n}\n","/**\r\n * Android scan mode\r\n */\r\nexport var ScanMode;\r\n(function (ScanMode) {\r\n    /**\r\n     * Perform Bluetooth LE scan in low power mode. This mode is enforced if the scanning application is not in foreground.\r\n     * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_POWER\r\n     */\r\n    ScanMode[ScanMode[\"SCAN_MODE_LOW_POWER\"] = 0] = \"SCAN_MODE_LOW_POWER\";\r\n    /**\r\n     * Perform Bluetooth LE scan in balanced power mode. (default) Scan results are returned at a rate that provides a good trade-off between scan frequency and power consumption.\r\n     * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_BALANCED\r\n     */\r\n    ScanMode[ScanMode[\"SCAN_MODE_BALANCED\"] = 1] = \"SCAN_MODE_BALANCED\";\r\n    /**\r\n     * Scan using highest duty cycle. It's recommended to only use this mode when the application is running in the foreground.\r\n     * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_LATENCY\r\n     */\r\n    ScanMode[ScanMode[\"SCAN_MODE_LOW_LATENCY\"] = 2] = \"SCAN_MODE_LOW_LATENCY\";\r\n})(ScanMode || (ScanMode = {}));\r\n/**\r\n * Android connection priority used in `requestConnectionPriority`\r\n */\r\nexport var ConnectionPriority;\r\n(function (ConnectionPriority) {\r\n    /**\r\n     * Use the connection parameters recommended by the Bluetooth SIG. This is the default value if no connection parameter update is requested.\r\n     * https://developer.android.com/reference/android/bluetooth/BluetoothGatt#CONNECTION_PRIORITY_BALANCED\r\n     */\r\n    ConnectionPriority[ConnectionPriority[\"CONNECTION_PRIORITY_BALANCED\"] = 0] = \"CONNECTION_PRIORITY_BALANCED\";\r\n    /**\r\n     * Request a high priority, low latency connection. An application should only request high priority connection parameters to transfer large amounts of data over LE quickly. Once the transfer is complete, the application should request CONNECTION_PRIORITY_BALANCED connection parameters to reduce energy use.\r\n     * https://developer.android.com/reference/android/bluetooth/BluetoothGatt#CONNECTION_PRIORITY_HIGH\r\n     */\r\n    ConnectionPriority[ConnectionPriority[\"CONNECTION_PRIORITY_HIGH\"] = 1] = \"CONNECTION_PRIORITY_HIGH\";\r\n    /**\r\n     * Request low power, reduced data rate connection parameters.\r\n     * https://developer.android.com/reference/android/bluetooth/BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER\r\n     */\r\n    ConnectionPriority[ConnectionPriority[\"CONNECTION_PRIORITY_LOW_POWER\"] = 2] = \"CONNECTION_PRIORITY_LOW_POWER\";\r\n})(ConnectionPriority || (ConnectionPriority = {}));\r\n//# sourceMappingURL=definitions.js.map","/**\r\n * Convert an array of numbers into a DataView.\r\n */\r\nexport function numbersToDataView(value) {\r\n    return new DataView(Uint8Array.from(value).buffer);\r\n}\r\n/**\r\n * Convert a DataView into an array of numbers.\r\n */\r\nexport function dataViewToNumbers(value) {\r\n    return Array.from(new Uint8Array(value.buffer, value.byteOffset, value.byteLength));\r\n}\r\n/**\r\n * Convert a string into a DataView.\r\n */\r\nexport function textToDataView(value) {\r\n    return numbersToDataView(value.split('').map((s) => s.charCodeAt(0)));\r\n}\r\n/**\r\n * Convert a DataView into a string.\r\n */\r\nexport function dataViewToText(value) {\r\n    return String.fromCharCode(...dataViewToNumbers(value));\r\n}\r\n/**\r\n * Convert a 16 bit UUID into a 128 bit UUID string\r\n * @param value number, e.g. 0x180d\r\n * @return string, e.g. '0000180d-0000-1000-8000-00805f9b34fb'\r\n */\r\nexport function numberToUUID(value) {\r\n    return `0000${value.toString(16).padStart(4, '0')}-0000-1000-8000-00805f9b34fb`;\r\n}\r\n/**\r\n * Convert a string of hex into a DataView of raw bytes.\r\n * Note: characters other than [0-9a-fA-F] are ignored\r\n * @param hex string of values, e.g. \"00 01 02\" or \"000102\"\r\n * @return DataView of raw bytes\r\n */\r\nexport function hexStringToDataView(hex) {\r\n    const bin = [];\r\n    let i, c, isEmpty = 1, buffer = 0;\r\n    for (i = 0; i < hex.length; i++) {\r\n        c = hex.charCodeAt(i);\r\n        if ((c > 47 && c < 58) || (c > 64 && c < 71) || (c > 96 && c < 103)) {\r\n            buffer = (buffer << 4) ^ ((c > 64 ? c + 9 : c) & 15);\r\n            if ((isEmpty ^= 1)) {\r\n                bin.push(buffer & 0xff);\r\n            }\r\n        }\r\n    }\r\n    return numbersToDataView(bin);\r\n}\r\nexport function dataViewToHexString(value) {\r\n    return dataViewToNumbers(value)\r\n        .map((n) => {\r\n        let s = n.toString(16);\r\n        if (s.length == 1) {\r\n            s = '0' + s;\r\n        }\r\n        return s;\r\n    })\r\n        .join('');\r\n}\r\nexport function webUUIDToString(uuid) {\r\n    if (typeof uuid === 'string') {\r\n        return uuid;\r\n    }\r\n    else if (typeof uuid === 'number') {\r\n        return numberToUUID(uuid);\r\n    }\r\n    else {\r\n        throw new Error('Invalid UUID');\r\n    }\r\n}\r\nexport function mapToObject(map) {\r\n    const obj = {};\r\n    if (!map) {\r\n        return undefined;\r\n    }\r\n    map.forEach((value, key) => {\r\n        obj[key.toString()] = value;\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * Convert Data or Uint8Array to Uint8Array.\r\n * @param value DataView, Uint8Array, or undefined\r\n * @return Uint8Array or undefined\r\n */\r\nexport function toUint8Array(value) {\r\n    if (value === undefined) {\r\n        return undefined;\r\n    }\r\n    if (typeof value === 'string') {\r\n        const dataView = hexStringToDataView(value);\r\n        return new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength);\r\n    }\r\n    if (value instanceof DataView) {\r\n        return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);\r\n    }\r\n    return value; // Already Uint8Array\r\n}\r\n/**\r\n * Convert Data, Uint8Array, or string to hex string.\r\n * @param value DataView, Uint8Array, or undefined\r\n * @return hex string or undefined\r\n */\r\nexport function toHexString(value) {\r\n    if (value === undefined) {\r\n        return undefined;\r\n    }\r\n    if (value instanceof DataView) {\r\n        return dataViewToHexString(value);\r\n    }\r\n    // Uint8Array\r\n    return dataViewToHexString(new DataView(value.buffer, value.byteOffset, value.byteLength));\r\n}\r\n//# sourceMappingURL=conversion.js.map","import { registerPlugin } from '@capacitor/core';\r\nexport const BluetoothLe = registerPlugin('BluetoothLe', {\r\n    web: () => import('./web').then((m) => new m.BluetoothLeWeb()),\r\n});\r\n//# sourceMappingURL=plugin.js.map","const makeQueue = () => {\r\n    let currentTask = Promise.resolve();\r\n    // create a new promise so that errors can be bubbled\r\n    // up to the caller without being caught by the queue\r\n    return (fn) => new Promise((resolve, reject) => {\r\n        currentTask = currentTask\r\n            .then(() => fn())\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n};\r\nexport function getQueue(enabled) {\r\n    if (enabled) {\r\n        return makeQueue();\r\n    }\r\n    return (fn) => fn();\r\n}\r\n//# sourceMappingURL=queue.js.map","export function parseUUID(uuid) {\r\n    if (typeof uuid !== 'string') {\r\n        throw new Error(`Invalid UUID type ${typeof uuid}. Expected string.`);\r\n    }\r\n    uuid = uuid.toLowerCase();\r\n    const is128BitUuid = uuid.search(/^[0-9a-f]{8}\\b-[0-9a-f]{4}\\b-[0-9a-f]{4}\\b-[0-9a-f]{4}\\b-[0-9a-f]{12}$/) >= 0;\r\n    if (!is128BitUuid) {\r\n        throw new Error(`Invalid UUID format ${uuid}. Expected 128 bit string (e.g. \"0000180d-0000-1000-8000-00805f9b34fb\").`);\r\n    }\r\n    return uuid;\r\n}\r\n//# sourceMappingURL=validators.js.map","import { Capacitor } from '@capacitor/core';\r\nimport { dataViewToHexString, hexStringToDataView, toUint8Array, toHexString } from './conversion';\r\nimport { BluetoothLe } from './plugin';\r\nimport { getQueue } from './queue';\r\nimport { parseUUID } from './validators';\r\nclass BleClientClass {\r\n    constructor() {\r\n        this.scanListener = null;\r\n        this.eventListeners = new Map();\r\n        this.queue = getQueue(true);\r\n    }\r\n    enableQueue() {\r\n        this.queue = getQueue(true);\r\n    }\r\n    disableQueue() {\r\n        this.queue = getQueue(false);\r\n    }\r\n    async initialize(options) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.initialize(options);\r\n        });\r\n    }\r\n    async isEnabled() {\r\n        const enabled = await this.queue(async () => {\r\n            const result = await BluetoothLe.isEnabled();\r\n            return result.value;\r\n        });\r\n        return enabled;\r\n    }\r\n    async requestEnable() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.requestEnable();\r\n        });\r\n    }\r\n    async enable() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.enable();\r\n        });\r\n    }\r\n    async disable() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.disable();\r\n        });\r\n    }\r\n    async startEnabledNotifications(callback) {\r\n        await this.queue(async () => {\r\n            var _a;\r\n            const key = `onEnabledChanged`;\r\n            await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n            const listener = await BluetoothLe.addListener(key, (result) => {\r\n                callback(result.value);\r\n            });\r\n            this.eventListeners.set(key, listener);\r\n            await BluetoothLe.startEnabledNotifications();\r\n        });\r\n    }\r\n    async stopEnabledNotifications() {\r\n        await this.queue(async () => {\r\n            var _a;\r\n            const key = `onEnabledChanged`;\r\n            await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n            this.eventListeners.delete(key);\r\n            await BluetoothLe.stopEnabledNotifications();\r\n        });\r\n    }\r\n    async isLocationEnabled() {\r\n        const enabled = await this.queue(async () => {\r\n            const result = await BluetoothLe.isLocationEnabled();\r\n            return result.value;\r\n        });\r\n        return enabled;\r\n    }\r\n    async openLocationSettings() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.openLocationSettings();\r\n        });\r\n    }\r\n    async openBluetoothSettings() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.openBluetoothSettings();\r\n        });\r\n    }\r\n    async openAppSettings() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.openAppSettings();\r\n        });\r\n    }\r\n    async setDisplayStrings(displayStrings) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.setDisplayStrings(displayStrings);\r\n        });\r\n    }\r\n    async requestDevice(options) {\r\n        options = options ? this.validateRequestBleDeviceOptions(options) : undefined;\r\n        const result = await this.queue(async () => {\r\n            const device = await BluetoothLe.requestDevice(options);\r\n            return device;\r\n        });\r\n        return result;\r\n    }\r\n    async requestLEScan(options, callback) {\r\n        options = this.validateRequestBleDeviceOptions(options);\r\n        await this.queue(async () => {\r\n            var _a;\r\n            await ((_a = this.scanListener) === null || _a === void 0 ? void 0 : _a.remove());\r\n            this.scanListener = await BluetoothLe.addListener('onScanResult', (resultInternal) => {\r\n                const result = Object.assign(Object.assign({}, resultInternal), { manufacturerData: this.convertObject(resultInternal.manufacturerData), serviceData: this.convertObject(resultInternal.serviceData), rawAdvertisement: resultInternal.rawAdvertisement\r\n                        ? this.convertValue(resultInternal.rawAdvertisement)\r\n                        : undefined });\r\n                callback(result);\r\n            });\r\n            await BluetoothLe.requestLEScan(options);\r\n        });\r\n    }\r\n    async stopLEScan() {\r\n        await this.queue(async () => {\r\n            var _a;\r\n            await ((_a = this.scanListener) === null || _a === void 0 ? void 0 : _a.remove());\r\n            this.scanListener = null;\r\n            await BluetoothLe.stopLEScan();\r\n        });\r\n    }\r\n    async getDevices(deviceIds) {\r\n        if (!Array.isArray(deviceIds)) {\r\n            throw new Error('deviceIds must be an array');\r\n        }\r\n        return this.queue(async () => {\r\n            const result = await BluetoothLe.getDevices({ deviceIds });\r\n            return result.devices;\r\n        });\r\n    }\r\n    async getConnectedDevices(services) {\r\n        if (!Array.isArray(services)) {\r\n            throw new Error('services must be an array');\r\n        }\r\n        services = services.map(parseUUID);\r\n        return this.queue(async () => {\r\n            const result = await BluetoothLe.getConnectedDevices({ services });\r\n            return result.devices;\r\n        });\r\n    }\r\n    async getBondedDevices() {\r\n        return this.queue(async () => {\r\n            const result = await BluetoothLe.getBondedDevices();\r\n            return result.devices;\r\n        });\r\n    }\r\n    async connect(deviceId, onDisconnect, options) {\r\n        await this.queue(async () => {\r\n            var _a;\r\n            if (onDisconnect) {\r\n                const key = `disconnected|${deviceId}`;\r\n                await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n                const listener = await BluetoothLe.addListener(key, () => {\r\n                    onDisconnect(deviceId);\r\n                });\r\n                this.eventListeners.set(key, listener);\r\n            }\r\n            await BluetoothLe.connect(Object.assign({ deviceId }, options));\r\n        });\r\n    }\r\n    async createBond(deviceId, options) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.createBond(Object.assign({ deviceId }, options));\r\n        });\r\n    }\r\n    async isBonded(deviceId) {\r\n        const isBonded = await this.queue(async () => {\r\n            const result = await BluetoothLe.isBonded({ deviceId });\r\n            return result.value;\r\n        });\r\n        return isBonded;\r\n    }\r\n    async disconnect(deviceId) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.disconnect({ deviceId });\r\n        });\r\n    }\r\n    async getServices(deviceId) {\r\n        const services = await this.queue(async () => {\r\n            const result = await BluetoothLe.getServices({ deviceId });\r\n            return result.services;\r\n        });\r\n        return services;\r\n    }\r\n    async discoverServices(deviceId) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.discoverServices({ deviceId });\r\n        });\r\n    }\r\n    async getMtu(deviceId) {\r\n        const value = await this.queue(async () => {\r\n            const result = await BluetoothLe.getMtu({ deviceId });\r\n            return result.value;\r\n        });\r\n        return value;\r\n    }\r\n    async requestConnectionPriority(deviceId, connectionPriority) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.requestConnectionPriority({ deviceId, connectionPriority });\r\n        });\r\n    }\r\n    async readRssi(deviceId) {\r\n        const value = await this.queue(async () => {\r\n            const result = await BluetoothLe.readRssi({ deviceId });\r\n            return parseFloat(result.value);\r\n        });\r\n        return value;\r\n    }\r\n    async read(deviceId, service, characteristic, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        const value = await this.queue(async () => {\r\n            const result = await BluetoothLe.read(Object.assign({ deviceId,\r\n                service,\r\n                characteristic }, options));\r\n            return this.convertValue(result.value);\r\n        });\r\n        return value;\r\n    }\r\n    async write(deviceId, service, characteristic, value, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        return this.queue(async () => {\r\n            if (!(value === null || value === void 0 ? void 0 : value.buffer)) {\r\n                throw new Error('Invalid data.');\r\n            }\r\n            let writeValue = value;\r\n            if (Capacitor.getPlatform() !== 'web') {\r\n                // on native we can only write strings\r\n                writeValue = dataViewToHexString(value);\r\n            }\r\n            await BluetoothLe.write(Object.assign({ deviceId,\r\n                service,\r\n                characteristic, value: writeValue }, options));\r\n        });\r\n    }\r\n    async writeWithoutResponse(deviceId, service, characteristic, value, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        await this.queue(async () => {\r\n            if (!(value === null || value === void 0 ? void 0 : value.buffer)) {\r\n                throw new Error('Invalid data.');\r\n            }\r\n            let writeValue = value;\r\n            if (Capacitor.getPlatform() !== 'web') {\r\n                // on native we can only write strings\r\n                writeValue = dataViewToHexString(value);\r\n            }\r\n            await BluetoothLe.writeWithoutResponse(Object.assign({ deviceId,\r\n                service,\r\n                characteristic, value: writeValue }, options));\r\n        });\r\n    }\r\n    async readDescriptor(deviceId, service, characteristic, descriptor, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        descriptor = parseUUID(descriptor);\r\n        const value = await this.queue(async () => {\r\n            const result = await BluetoothLe.readDescriptor(Object.assign({ deviceId,\r\n                service,\r\n                characteristic,\r\n                descriptor }, options));\r\n            return this.convertValue(result.value);\r\n        });\r\n        return value;\r\n    }\r\n    async writeDescriptor(deviceId, service, characteristic, descriptor, value, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        descriptor = parseUUID(descriptor);\r\n        return this.queue(async () => {\r\n            if (!(value === null || value === void 0 ? void 0 : value.buffer)) {\r\n                throw new Error('Invalid data.');\r\n            }\r\n            let writeValue = value;\r\n            if (Capacitor.getPlatform() !== 'web') {\r\n                // on native we can only write strings\r\n                writeValue = dataViewToHexString(value);\r\n            }\r\n            await BluetoothLe.writeDescriptor(Object.assign({ deviceId,\r\n                service,\r\n                characteristic,\r\n                descriptor, value: writeValue }, options));\r\n        });\r\n    }\r\n    async startNotifications(deviceId, service, characteristic, callback, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        await this.queue(async () => {\r\n            var _a;\r\n            const key = `notification|${deviceId}|${service}|${characteristic}`;\r\n            await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n            const listener = await BluetoothLe.addListener(key, (event) => {\r\n                callback(this.convertValue(event === null || event === void 0 ? void 0 : event.value));\r\n            });\r\n            this.eventListeners.set(key, listener);\r\n            await BluetoothLe.startNotifications(Object.assign({ deviceId,\r\n                service,\r\n                characteristic }, options));\r\n        });\r\n    }\r\n    async stopNotifications(deviceId, service, characteristic) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        await this.queue(async () => {\r\n            var _a;\r\n            const key = `notification|${deviceId}|${service}|${characteristic}`;\r\n            await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n            this.eventListeners.delete(key);\r\n            await BluetoothLe.stopNotifications({\r\n                deviceId,\r\n                service,\r\n                characteristic,\r\n            });\r\n        });\r\n    }\r\n    validateRequestBleDeviceOptions(options) {\r\n        if (options.services) {\r\n            options.services = options.services.map(parseUUID);\r\n        }\r\n        if (options.optionalServices) {\r\n            options.optionalServices = options.optionalServices.map(parseUUID);\r\n        }\r\n        if (options.serviceData && Capacitor.getPlatform() !== 'web') {\r\n            // Native platforms: convert to hex strings\r\n            options.serviceData = options.serviceData.map((filter) => (Object.assign(Object.assign({}, filter), { serviceUuid: parseUUID(filter.serviceUuid), dataPrefix: toHexString(filter.dataPrefix), mask: toHexString(filter.mask) })));\r\n        }\r\n        if (options.manufacturerData) {\r\n            if (Capacitor.getPlatform() !== 'web') {\r\n                // Native platforms: convert to hex strings\r\n                options.manufacturerData = options.manufacturerData.map((filter) => (Object.assign(Object.assign({}, filter), { dataPrefix: toHexString(filter.dataPrefix), mask: toHexString(filter.mask) })));\r\n            }\r\n            else {\r\n                // Web platform: convert to Uint8Array for Web Bluetooth API\r\n                options.manufacturerData = options.manufacturerData.map((filter) => (Object.assign(Object.assign({}, filter), { dataPrefix: toUint8Array(filter.dataPrefix), mask: toUint8Array(filter.mask) })));\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n    convertValue(value) {\r\n        if (typeof value === 'string') {\r\n            return hexStringToDataView(value);\r\n        }\r\n        else if (value === undefined) {\r\n            return new DataView(new ArrayBuffer(0));\r\n        }\r\n        return value;\r\n    }\r\n    convertObject(obj) {\r\n        if (obj === undefined) {\r\n            return undefined;\r\n        }\r\n        const result = {};\r\n        for (const key of Object.keys(obj)) {\r\n            result[key] = this.convertValue(obj[key]);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexport const BleClient = new BleClientClass();\r\n//# sourceMappingURL=bleClient.js.map","/**\n * Storage for Bluetooth Connection Metadata\n */\n\nimport type { SensorType } from '../types/connections.js';\n\nconst STORAGE_KEY = 'bpt_last_device_ids';\nconst DEVICE_NAMES_KEY = 'bpt_last_device_names';\n\nexport type SavedConnectionIds = Partial<Record<SensorType, string>>;\nexport type SavedDeviceNames = Partial<Record<SensorType, string>>;\n\nexport const connectionStorage = {\n    // Device ID storage\n    getIds(): SavedConnectionIds {\n        try {\n            const raw = localStorage.getItem(STORAGE_KEY);\n            return raw ? JSON.parse(raw) : {};\n        } catch (e) {\n            console.warn('Failed to read connection storage', e);\n            return {};\n        }\n    },\n\n    saveId(type: SensorType, id: string): void {\n        const ids = this.getIds();\n        ids[type] = id;\n        try {\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(ids));\n        } catch (e) {\n            console.warn('Failed to save connection storage', e);\n        }\n    },\n\n    clearId(type: SensorType): void {\n        const ids = this.getIds();\n        delete ids[type];\n        try {\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(ids));\n        } catch (e) {\n            console.warn('Failed to save connection storage', e);\n        }\n    },\n\n    getId(type: SensorType): string | undefined {\n        return this.getIds()[type];\n    },\n\n    // Device name storage\n    getDeviceNames(): SavedDeviceNames {\n        try {\n            const raw = localStorage.getItem(DEVICE_NAMES_KEY);\n            return raw ? JSON.parse(raw) : {};\n        } catch (e) {\n            console.warn('Failed to read device names storage', e);\n            return {};\n        }\n    },\n\n    saveDeviceName(type: SensorType, name: string): void {\n        const names = this.getDeviceNames();\n        names[type] = name;\n        try {\n            localStorage.setItem(DEVICE_NAMES_KEY, JSON.stringify(names));\n        } catch (e) {\n            console.warn('Failed to save device name', e);\n        }\n    },\n\n    clearDeviceName(type: SensorType): void {\n        const names = this.getDeviceNames();\n        delete names[type];\n        try {\n            localStorage.setItem(DEVICE_NAMES_KEY, JSON.stringify(names));\n        } catch (e) {\n            console.warn('Failed to clear device name', e);\n        }\n    },\n\n    getDeviceName(type: SensorType): string | undefined {\n        return this.getDeviceNames()[type];\n    }\n};\n\n","/**\n * FTMS (Fitness Machine Service) Parser\n *\n * Handles parsing of Bluetooth LE data from Fitness Machines.\n *\n * Specs: https://www.bluetooth.com/specifications/specs/fitness-machine-service-1-0/\n *\n * Supported characteristics:\n * - Treadmill Data (0x2ACD)\n * - Rower Data (0x2AD1)\n * - Cross Trainer Data (0x2ACE)\n * - Indoor Bike Data (0x2AD2)\n */\n\nexport interface FTMSValues {\n    speed?: number; // km/h\n    averageSpeed?: number; // km/h\n    totalDistance?: number; // meters\n    incline?: number; // %\n    rampAngle?: number; // degrees\n}\n\nexport interface RowerValues {\n    strokeRate?: number; // strokes/min\n    strokeCount?: number; // total strokes\n    averageStrokeRate?: number; // strokes/min\n    totalDistance?: number; // meters\n    instantaneousPace?: number; // seconds/500m\n    averagePace?: number; // seconds/500m\n    instantaneousPower?: number; // watts\n    averagePower?: number; // watts\n    totalEnergy?: number; // kcal\n    heartRate?: number; // bpm\n    elapsedTime?: number; // seconds\n}\n\nexport interface CrossTrainerValues {\n    speed?: number; // km/h\n    averageSpeed?: number; // km/h\n    totalDistance?: number; // meters\n    stepPerMinute?: number; // steps/min\n    averageStepRate?: number; // steps/min\n    strideCount?: number; // total strides\n    positiveElevationGain?: number; // meters\n    negativeElevationGain?: number; // meters\n    incline?: number; // %\n    rampAngle?: number; // degrees\n    resistanceLevel?: number; // unitless\n    instantaneousPower?: number; // watts\n    averagePower?: number; // watts\n    totalEnergy?: number; // kcal\n    heartRate?: number; // bpm\n    elapsedTime?: number; // seconds\n}\n\nexport interface IndoorBikeValues {\n    speed?: number; // km/h\n    averageSpeed?: number; // km/h\n    cadence?: number; // rpm\n    averageCadence?: number; // rpm\n    totalDistance?: number; // meters\n    resistanceLevel?: number; // unitless\n    instantaneousPower?: number; // watts\n    averagePower?: number; // watts\n    totalEnergy?: number; // kcal\n    heartRate?: number; // bpm\n    elapsedTime?: number; // seconds\n}\n\nexport interface StepClimberValues {\n    floors?: number;\n    stepCount?: number;\n    stepRate?: number; // steps/min\n    averageStepRate?: number; // steps/min\n    positiveElevationGain?: number; // meters\n    instantaneousPower?: number; // watts\n    averagePower?: number; // watts\n    totalEnergy?: number; // kcal\n    heartRate?: number; // bpm\n    elapsedTime?: number; // seconds\n}\n\nexport interface RscValues {\n    speed: number; // km/h\n    cadence: number; // rpm\n    strideLength?: number; // meters\n    totalDistance?: number; // meters\n}\n\n/**\n * Parses Treadmill Data characteristic (0x2ACD)\n *\n * @param data DataView containing the raw bytes\n * @returns Parsed values object\n */\nexport const parseTreadmillData = (data: DataView): FTMSValues => {\n    // Check flags in first 2 bytes (16-bit LE)\n    const flags = data.getUint16(0, true);\n    let offset = 2;\n    const result: FTMSValues = {};\n\n    // Bit 0: More Data (ignored for now)\n    // Bit 1: Average Speed Present\n    const hasAverageSpeed = (flags & (1 << 1)) !== 0;\n    // Bit 2: Total Distance Present\n    const hasTotalDistance = (flags & (1 << 2)) !== 0;\n    // Bit 3: Inclination and Ramp Angle Present\n    const hasInclination = (flags & (1 << 3)) !== 0;\n\n    // Other bits ignored for now to avoid unused variable warnings\n    /*\n    // Bit 4: Elevation Gain Present\n    const hasElevationGain = (flags & (1 << 4)) !== 0;\n    // Bit 5: Instantaneous Pace Present\n    const hasPace = (flags & (1 << 5)) !== 0;\n    // Bit 6: Average Pace Present\n    const hasAveragePace = (flags & (1 << 6)) !== 0;\n    // Bit 7: Expended Energy Present\n    const hasEnergy = (flags & (1 << 7)) !== 0;\n    // Bit 8: Heart Rate Present\n    const hasHeartRate = (flags & (1 << 8)) !== 0;\n    // Bit 9: Metabolic Equivalent Present\n    const hasMetabolic = (flags & (1 << 9)) !== 0;\n    // Bit 10: Elapsed Time Present\n    const hasElapsedTime = (flags & (1 << 10)) !== 0;\n    // Bit 11: Remaining Time Present\n    const hasRemainingTime = (flags & (1 << 11)) !== 0;\n    // Bit 12: Force on Belt and Power Output Present\n    const hasForcePower = (flags & (1 << 12)) !== 0;\n    */\n\n    // Instantaneous Speed (Always present unless noted otherwise, but spec says \"C1\" - Mandatory)\n    // Unit: 0.01 km/h, uint16\n    // Note: Some legacy devices might interpret flags differently, but standard says first field after flags is Inst. Speed.\n    if (data.byteLength >= offset + 2) {\n        const rawSpeed = data.getUint16(offset, true);\n        result.speed = rawSpeed / 100.0;\n        offset += 2;\n    }\n\n    if (hasAverageSpeed && data.byteLength >= offset + 2) {\n        const rawAvgSpeed = data.getUint16(offset, true);\n        result.averageSpeed = rawAvgSpeed / 100.0;\n        offset += 2;\n    }\n\n    if (hasTotalDistance && data.byteLength >= offset + 3) {\n        // unit24 is tricky. Read 3 bytes.\n        // Little endian: byte[0] + byte[1]<<8 + byte[2]<<16\n        const b0 = data.getUint8(offset);\n        const b1 = data.getUint8(offset + 1);\n        const b2 = data.getUint8(offset + 2);\n        const rawDist = b0 + (b1 << 8) + (b2 << 16);\n\n        result.totalDistance = rawDist;\n        offset += 3;\n    }\n\n    if (hasInclination && data.byteLength >= offset + 4) {\n        // Inclination: sint16, 0.1 %\n        const rawIncline = data.getInt16(offset, true);\n        result.incline = rawIncline / 10.0;\n        offset += 2;\n\n        // Ramp Angle: sint16, 0.1 degree\n        const rawRamp = data.getInt16(offset, true);\n        result.rampAngle = rawRamp / 10.0;\n        offset += 2;\n    }\n\n    // We can parse more if needed (Heart Rate, etc.)\n\n    return result;\n};\n\n/**\n * Helper to read uint24 (3 bytes, little-endian)\n */\nconst readUint24 = (data: DataView, offset: number): number => {\n    const b0 = data.getUint8(offset);\n    const b1 = data.getUint8(offset + 1);\n    const b2 = data.getUint8(offset + 2);\n    return b0 + (b1 << 8) + (b2 << 16);\n};\n\n/**\n * Parses Rower Data characteristic (0x2AD1)\n *\n * @param data DataView containing the raw bytes\n * @returns Parsed values object\n */\nexport const parseRowerData = (data: DataView): RowerValues => {\n    const flags = data.getUint16(0, true);\n    let offset = 2;\n    const result: RowerValues = {};\n\n    // Bit 0: More Data (0 = first of two, 1 = second part)\n    // Bit 1: Average Stroke Rate Present\n    const hasAverageStrokeRate = (flags & (1 << 1)) !== 0;\n    // Bit 2: Total Distance Present\n    const hasTotalDistance = (flags & (1 << 2)) !== 0;\n    // Bit 3: Instantaneous Pace Present\n    const hasInstantaneousPace = (flags & (1 << 3)) !== 0;\n    // Bit 4: Average Pace Present\n    const hasAveragePace = (flags & (1 << 4)) !== 0;\n    // Bit 5: Instantaneous Power Present\n    const hasInstantaneousPower = (flags & (1 << 5)) !== 0;\n    // Bit 6: Average Power Present\n    const hasAveragePower = (flags & (1 << 6)) !== 0;\n    // Bit 7: Resistance Level Present (ignored)\n    // Bit 8: Expended Energy Present\n    const hasExpendedEnergy = (flags & (1 << 8)) !== 0;\n    // Bit 9: Heart Rate Present\n    const hasHeartRate = (flags & (1 << 9)) !== 0;\n    // Bit 11: Elapsed Time Present\n    const hasElapsedTime = (flags & (1 << 11)) !== 0;\n\n    // Stroke Rate: uint8, 0.5 strokes/min resolution\n    if (data.byteLength >= offset + 1) {\n        result.strokeRate = data.getUint8(offset) * 0.5;\n        offset += 1;\n    }\n\n    // Stroke Count: uint16\n    if (data.byteLength >= offset + 2) {\n        result.strokeCount = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasAverageStrokeRate && data.byteLength >= offset + 1) {\n        result.averageStrokeRate = data.getUint8(offset) * 0.5;\n        offset += 1;\n    }\n\n    if (hasTotalDistance && data.byteLength >= offset + 3) {\n        result.totalDistance = readUint24(data, offset);\n        offset += 3;\n    }\n\n    if (hasInstantaneousPace && data.byteLength >= offset + 2) {\n        result.instantaneousPace = data.getUint16(offset, true); // seconds per 500m\n        offset += 2;\n    }\n\n    if (hasAveragePace && data.byteLength >= offset + 2) {\n        result.averagePace = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasInstantaneousPower && data.byteLength >= offset + 2) {\n        result.instantaneousPower = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    if (hasAveragePower && data.byteLength >= offset + 2) {\n        result.averagePower = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    // Skip Resistance Level if present (bit 7)\n    if ((flags & (1 << 7)) !== 0 && data.byteLength >= offset + 2) {\n        offset += 2;\n    }\n\n    if (hasExpendedEnergy && data.byteLength >= offset + 5) {\n        result.totalEnergy = data.getUint16(offset, true);\n        offset += 5; // Total Energy (2) + Energy per Hour (2) + Energy per Minute (1)\n    }\n\n    if (hasHeartRate && data.byteLength >= offset + 1) {\n        result.heartRate = data.getUint8(offset);\n        offset += 1;\n    }\n\n    // Skip Metabolic Equivalent (bit 10) if present\n    if ((flags & (1 << 10)) !== 0 && data.byteLength >= offset + 1) {\n        offset += 1;\n    }\n\n    if (hasElapsedTime && data.byteLength >= offset + 2) {\n        result.elapsedTime = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    return result;\n};\n\n/**\n * Parses Cross Trainer Data characteristic (0x2ACE)\n *\n * @param data DataView containing the raw bytes\n * @returns Parsed values object\n */\nexport const parseCrossTrainerData = (data: DataView): CrossTrainerValues => {\n    // Cross Trainer Data uses 24-bit flags\n    const flags = readUint24(data, 0);\n    let offset = 3;\n    const result: CrossTrainerValues = {};\n\n    // Bit 0: More Data\n    // Bit 1: Average Speed Present\n    const hasAverageSpeed = (flags & (1 << 1)) !== 0;\n    // Bit 2: Total Distance Present\n    const hasTotalDistance = (flags & (1 << 2)) !== 0;\n    // Bit 3: Step Count Present\n    const hasStepCount = (flags & (1 << 3)) !== 0;\n    // Bit 4: Stride Count Present\n    const hasStrideCount = (flags & (1 << 4)) !== 0;\n    // Bit 5: Elevation Gain Present\n    const hasElevationGain = (flags & (1 << 5)) !== 0;\n    // Bit 6: Inclination and Ramp Angle Present\n    const hasInclination = (flags & (1 << 6)) !== 0;\n    // Bit 7: Resistance Level Present\n    const hasResistanceLevel = (flags & (1 << 7)) !== 0;\n    // Bit 8: Instantaneous Power Present\n    const hasInstantaneousPower = (flags & (1 << 8)) !== 0;\n    // Bit 9: Average Power Present\n    const hasAveragePower = (flags & (1 << 9)) !== 0;\n    // Bit 10: Expended Energy Present\n    const hasExpendedEnergy = (flags & (1 << 10)) !== 0;\n    // Bit 11: Heart Rate Present\n    const hasHeartRate = (flags & (1 << 11)) !== 0;\n    // Bit 13: Elapsed Time Present\n    const hasElapsedTime = (flags & (1 << 13)) !== 0;\n\n    // Instantaneous Speed: uint16, 0.01 km/h\n    if (data.byteLength >= offset + 2) {\n        result.speed = data.getUint16(offset, true) / 100.0;\n        offset += 2;\n    }\n\n    if (hasAverageSpeed && data.byteLength >= offset + 2) {\n        result.averageSpeed = data.getUint16(offset, true) / 100.0;\n        offset += 2;\n    }\n\n    if (hasTotalDistance && data.byteLength >= offset + 3) {\n        result.totalDistance = readUint24(data, offset);\n        offset += 3;\n    }\n\n    if (hasStepCount && data.byteLength >= offset + 4) {\n        result.stepPerMinute = data.getUint16(offset, true);\n        offset += 2;\n        result.averageStepRate = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasStrideCount && data.byteLength >= offset + 2) {\n        result.strideCount = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasElevationGain && data.byteLength >= offset + 4) {\n        result.positiveElevationGain = data.getUint16(offset, true);\n        offset += 2;\n        result.negativeElevationGain = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasInclination && data.byteLength >= offset + 4) {\n        result.incline = data.getInt16(offset, true) / 10.0;\n        offset += 2;\n        result.rampAngle = data.getInt16(offset, true) / 10.0;\n        offset += 2;\n    }\n\n    if (hasResistanceLevel && data.byteLength >= offset + 2) {\n        result.resistanceLevel = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    if (hasInstantaneousPower && data.byteLength >= offset + 2) {\n        result.instantaneousPower = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    if (hasAveragePower && data.byteLength >= offset + 2) {\n        result.averagePower = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    if (hasExpendedEnergy && data.byteLength >= offset + 5) {\n        result.totalEnergy = data.getUint16(offset, true);\n        offset += 5; // Total + per hour + per minute\n    }\n\n    if (hasHeartRate && data.byteLength >= offset + 1) {\n        result.heartRate = data.getUint8(offset);\n        offset += 1;\n    }\n\n    // Skip Metabolic Equivalent (bit 12)\n    if ((flags & (1 << 12)) !== 0 && data.byteLength >= offset + 1) {\n        offset += 1;\n    }\n\n    if (hasElapsedTime && data.byteLength >= offset + 2) {\n        result.elapsedTime = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    return result;\n};\n\n/**\n * Parses Indoor Bike Data characteristic (0x2AD2)\n *\n * @param data DataView containing the raw bytes\n * @returns Parsed values object\n */\nexport const parseIndoorBikeData = (data: DataView): IndoorBikeValues => {\n    const flags = data.getUint16(0, true);\n    let offset = 2;\n    const result: IndoorBikeValues = {};\n\n    // Bit 0: More Data\n    // Bit 1: Average Speed Present\n    const hasAverageSpeed = (flags & (1 << 1)) !== 0;\n    // Bit 2: Instantaneous Cadence Present\n    const hasInstantaneousCadence = (flags & (1 << 2)) !== 0;\n    // Bit 3: Average Cadence Present\n    const hasAverageCadence = (flags & (1 << 3)) !== 0;\n    // Bit 4: Total Distance Present\n    const hasTotalDistance = (flags & (1 << 4)) !== 0;\n    // Bit 5: Resistance Level Present\n    const hasResistanceLevel = (flags & (1 << 5)) !== 0;\n    // Bit 6: Instantaneous Power Present\n    const hasInstantaneousPower = (flags & (1 << 6)) !== 0;\n    // Bit 7: Average Power Present\n    const hasAveragePower = (flags & (1 << 7)) !== 0;\n    // Bit 8: Expended Energy Present\n    const hasExpendedEnergy = (flags & (1 << 8)) !== 0;\n    // Bit 9: Heart Rate Present\n    const hasHeartRate = (flags & (1 << 9)) !== 0;\n    // Bit 11: Elapsed Time Present\n    const hasElapsedTime = (flags & (1 << 11)) !== 0;\n\n    // Instantaneous Speed: uint16, 0.01 km/h\n    if (data.byteLength >= offset + 2) {\n        result.speed = data.getUint16(offset, true) / 100.0;\n        offset += 2;\n    }\n\n    if (hasAverageSpeed && data.byteLength >= offset + 2) {\n        result.averageSpeed = data.getUint16(offset, true) / 100.0;\n        offset += 2;\n    }\n\n    if (hasInstantaneousCadence && data.byteLength >= offset + 2) {\n        result.cadence = data.getUint16(offset, true) / 2.0; // 0.5 rpm resolution\n        offset += 2;\n    }\n\n    if (hasAverageCadence && data.byteLength >= offset + 2) {\n        result.averageCadence = data.getUint16(offset, true) / 2.0;\n        offset += 2;\n    }\n\n    if (hasTotalDistance && data.byteLength >= offset + 3) {\n        result.totalDistance = readUint24(data, offset);\n        offset += 3;\n    }\n\n    if (hasResistanceLevel && data.byteLength >= offset + 2) {\n        result.resistanceLevel = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    if (hasInstantaneousPower && data.byteLength >= offset + 2) {\n        result.instantaneousPower = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    if (hasAveragePower && data.byteLength >= offset + 2) {\n        result.averagePower = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    if (hasExpendedEnergy && data.byteLength >= offset + 5) {\n        result.totalEnergy = data.getUint16(offset, true);\n        offset += 5;\n    }\n\n    if (hasHeartRate && data.byteLength >= offset + 1) {\n        result.heartRate = data.getUint8(offset);\n        offset += 1;\n    }\n\n    // Skip Metabolic Equivalent (bit 10)\n    if ((flags & (1 << 10)) !== 0 && data.byteLength >= offset + 1) {\n        offset += 1;\n    }\n\n    if (hasElapsedTime && data.byteLength >= offset + 2) {\n        result.elapsedTime = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    return result;\n};\n\n/**\n * Parses Step Climber Data characteristic (0x2ACF)\n *\n * @param data DataView containing the raw bytes\n * @returns Parsed values object\n */\nexport const parseStepClimberData = (data: DataView): StepClimberValues => {\n    // Flags (16-bit)\n    const flags = data.getUint16(0, true);\n    let offset = 2;\n    const result: StepClimberValues = {};\n\n    // Bit 0: More Data (ignored)\n    const hasFloors = (flags & (1 << 1)) !== 0;\n    const hasStepCount = (flags & (1 << 2)) !== 0;\n    const hasStepRate = (flags & (1 << 3)) !== 0;\n    const hasAverageStepRate = (flags & (1 << 4)) !== 0;\n    const hasPositiveElevationGain = (flags & (1 << 5)) !== 0;\n    const hasInstantaneousPower = (flags & (1 << 6)) !== 0;\n    const hasAveragePower = (flags & (1 << 7)) !== 0;\n    const hasExpendedEnergy = (flags & (1 << 8)) !== 0;\n    const hasHeartRate = (flags & (1 << 9)) !== 0;\n    const hasMetabolicEquivalent = (flags & (1 << 10)) !== 0;\n    const hasElapsedTime = (flags & (1 << 11)) !== 0;\n\n    if (hasFloors && data.byteLength >= offset + 2) {\n        result.floors = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasStepCount && data.byteLength >= offset + 2) {\n        result.stepCount = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasStepRate && data.byteLength >= offset + 2) {\n        result.stepRate = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasAverageStepRate && data.byteLength >= offset + 2) {\n        result.averageStepRate = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasPositiveElevationGain && data.byteLength >= offset + 2) {\n        result.positiveElevationGain = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    if (hasInstantaneousPower && data.byteLength >= offset + 2) {\n        result.instantaneousPower = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    if (hasAveragePower && data.byteLength >= offset + 2) {\n        result.averagePower = data.getInt16(offset, true);\n        offset += 2;\n    }\n\n    if (hasExpendedEnergy && data.byteLength >= offset + 5) {\n        result.totalEnergy = data.getUint16(offset, true);\n        offset += 5;\n    }\n\n    if (hasHeartRate && data.byteLength >= offset + 1) {\n        result.heartRate = data.getUint8(offset);\n        offset += 1;\n    }\n\n    if (hasMetabolicEquivalent && data.byteLength >= offset + 1) {\n        offset += 1;\n    }\n\n    if (hasElapsedTime && data.byteLength >= offset + 2) {\n        result.elapsedTime = data.getUint16(offset, true);\n        offset += 2;\n    }\n\n    return result;\n};\n\n/**\n * Parses RSC Measurement characteristic (0x2A53)\n *\n * @param data DataView containing the raw bytes\n * @returns Parsed values object\n */\nexport const parseRscData = (data: DataView): RscValues => {\n    const flags = data.getUint8(0);\n    let offset = 1;\n\n    // Instantaneous Speed (uint16, m/s, 1/256 unit)\n    const speedRaw = data.getUint16(offset, true);\n    // Convert to km/h: (val / 256) * 3.6\n    const speed = (speedRaw / 256.0) * 3.6;\n    offset += 2;\n\n    // Instantaneous Cadence (uint8, rpm)\n    const cadence = data.getUint8(offset);\n    offset += 1;\n\n    const result: RscValues = {\n        speed,\n        cadence\n    };\n\n    // Bit 0: Instantaneous Stride Length Present\n    const hasStrideLength = (flags & 0x01) !== 0;\n    // Bit 1: Total Distance Present\n    const hasTotalDistance = (flags & 0x02) !== 0;\n\n    if (hasStrideLength && data.byteLength >= offset + 2) {\n        // unit: centimeters, uint16\n        const strideCm = data.getUint16(offset, true);\n        result.strideLength = strideCm / 100.0;\n        offset += 2;\n    }\n\n    if (hasTotalDistance && data.byteLength >= offset + 4) {\n        // unit: decimeters, uint32\n        const distDm = data.getUint32(offset, true);\n        result.totalDistance = distDm / 10.0;\n        offset += 4;\n    }\n\n    return result;\n};\n\n\n","/**\n * Bluetooth Debug Service\n *\n * Handles capturing, storing, and exporting raw Bluetooth sensor data\n * for debugging purposes.\n */\n\nimport { saveDebugLog, getDebugLogs, clearDebugLogs } from '../../storage/workoutStorage.js';\nimport { getSettings } from '../../config/settings.js';\n\ntype DebugListener = (sensor: string, hex: string) => void;\n\n/**\n * Service for logging raw Bluetooth data\n */\nexport const BluetoothDebugService = {\n    listeners: new Set<DebugListener>(),\n\n    /**\n     * Check if debug mode is enabled\n     */\n    isEnabled(): boolean {\n        // Try to avoid excessive localStorage reads by checking if we are in a tight loop\n        // But getSettings parses JSON, so maybe we should cache this?\n        // for now, let's just read it.\n        const settings = getSettings();\n        return !!settings.debugMode;\n    },\n\n    /**\n     * Log a raw data packet\n     * @param sensor - The sensor type identifier\n     * @param data - The raw DataView from the Bluetooth characteristic\n     */\n    async log(sensor: string, data: DataView): Promise<void> {\n        // Always notify listeners, even if storage logging is disabled?\n        // Let's assume yes for the debug page to work without persisting.\n        const hex = this.bufferToHex(data.buffer);\n\n        this.listeners.forEach((listener) => listener(sensor, hex));\n\n        if (!this.isEnabled()) return;\n\n        try {\n            await saveDebugLog(sensor, hex);\n        } catch (e) {\n            console.warn('Failed to log debug data', e);\n        }\n    },\n\n    /**\n     * Add a listener for real-time debug data\n     */\n    addListener(listener: DebugListener): void {\n        this.listeners.add(listener);\n    },\n\n    /**\n     * Remove a listener\n     */\n    removeListener(listener: DebugListener): void {\n        this.listeners.delete(listener);\n    },\n\n    /**\n     * Convert ArrayBuffer to Hex string\n     */\n    bufferToHex(buffer: ArrayBufferLike): string {\n        return [...new Uint8Array(buffer)]\n            .map((b) => b.toString(16).padStart(2, '0'))\n            .join('')\n            .toUpperCase();\n    },\n\n    /**\n     * Export all logs as a JSON file\n     */\n    async exportLogs(): Promise<void> {\n        const logs = await getDebugLogs();\n        const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `bpt-debug-logs-${Date.now()}.json`;\n        document.body.appendChild(a);\n        a.click();\n\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    },\n\n    /**\n     * Clear all debug logs\n     */\n    async clearLogs(): Promise<void> {\n        await clearDebugLogs();\n    },\n\n    /**\n     * Get count of stored logs\n     */\n    async getLogCount(): Promise<number> {\n        const logs = await getDebugLogs();\n        return logs.length;\n    },\n};\n","import { BleClient } from '@capacitor-community/bluetooth-le';\nimport { connectionStorage } from '../../storage/connectionStorage.js';\nimport type {\n    SensorConnection,\n    TreadmillConnection,\n    MeasurementListener,\n    TreadmillListener,\n    ConnectionStatusListener,\n    ConnectionStatus,\n} from '../../types/bluetooth.js';\nimport type { Measurement, TreadmillMeasurement } from '../../types/measurements.js';\nimport { parseTreadmillData } from './ftms.js';\nimport { BluetoothDebugService } from '../debug/BluetoothDebugService.js';\n\nconst CYCLING_POWER_SERVICE = '00001818-0000-1000-8000-00805f9b34fb';\nconst CYCLING_POWER_MEASUREMENT = '00002a63-0000-1000-8000-00805f9b34fb';\n\nconst HEART_RATE_SERVICE = '0000180d-0000-1000-8000-00805f9b34fb';\nconst HEART_RATE_MEASUREMENT = '00002a37-0000-1000-8000-00805f9b34fb';\n\nconst CYCLING_SPEED_AND_CADENCE_SERVICE = '00001816-0000-1000-8000-00805f9b34fb';\nconst CSC_MEASUREMENT = '00002a5b-0000-1000-8000-00805f9b34fb';\n\nconst FITNESS_MACHINE_SERVICE = '00001826-0000-1000-8000-00805f9b34fb';\nconst TREADMILL_DATA_CHARACTERISTIC = '00002acd-0000-1000-8000-00805f9b34fb';\n\n/** Maximum reconnection attempts before giving up */\nconst MAX_RECONNECT_ATTEMPTS = 5;\n/** Base delay between reconnection attempts (ms) */\nconst RECONNECT_BASE_DELAY = 1000;\n\n// Track if BleClient has been initialized\nlet isBleInitialized = false;\n\nconst ensureBleInitialized = async () => {\n    if (!isBleInitialized) {\n        try {\n            await BleClient.initialize();\n            isBleInitialized = true;\n        } catch (error) {\n            console.error('Failed to initialize BleClient:', error);\n            // On some versions/platforms, re-initializing might throw but not be fatal if already initialized.\n            // But usually we want to propagate this error if it's the first time.\n            throw error;\n        }\n    }\n};\n\nexport const connectPowerNative = async (previousDeviceId?: string): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let deviceId: string | null = previousDeviceId || null;\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let deviceName = 'Power Sensor';\n\n    await ensureBleInitialized();\n\n    if (!deviceId) {\n        try {\n            const device = await BleClient.requestDevice({\n                services: [CYCLING_POWER_SERVICE],\n                optionalServices: [],\n            });\n            deviceId = device.deviceId;\n            deviceName = device.name || 'Power Sensor';\n        } catch (error) {\n            console.error('Error requesting Power device:', error);\n            throw error;\n        }\n    } else {\n        deviceName = 'Restored Power Sensor';\n    }\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!deviceId) return;\n        await BleClient.connect(deviceId, onDisconnect);\n        connectionStorage.saveId('power', deviceId);\n        notifyStatus('connected');\n\n        await BleClient.startNotifications(deviceId, CYCLING_POWER_SERVICE, CYCLING_POWER_MEASUREMENT, (value) => {\n            BluetoothDebugService.log(deviceName, value);\n            // Cycling power measurement format: bytes 2-3 contain instantaneous power (little-endian)\n            const power = value.getInt16(2, true);\n            const entry: Measurement = { timestamp: Date.now(), value: power };\n            listeners.forEach((listener) => listener(entry));\n        });\n        reconnectAttempts = 0;\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Native Power sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Native Power sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Native Power sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Native Power sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    const onDisconnect = (disconnectedDeviceId: string) => {\n        if (disconnectedDeviceId === deviceId && !isManualDisconnect) {\n            console.log('Native Power sensor: Disconnected');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    };\n\n    await connect();\n\n    return {\n        disconnect: async () => {\n            isManualDisconnect = true;\n            if (deviceId) {\n                try {\n                    await BleClient.stopNotifications(deviceId, CYCLING_POWER_SERVICE, CYCLING_POWER_MEASUREMENT);\n                    await BleClient.disconnect(deviceId);\n                } catch (e) {\n                    console.error('Error disconnecting native bluetooth:', e);\n                }\n            }\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectHeartRateNative = async (previousDeviceId?: string): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let deviceId: string | null = previousDeviceId || null;\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let deviceName = 'Heart Rate Monitor';\n\n    await ensureBleInitialized();\n\n    if (!deviceId) {\n        try {\n            const device = await BleClient.requestDevice({\n                services: [HEART_RATE_SERVICE],\n                optionalServices: [HEART_RATE_SERVICE],\n            });\n            deviceId = device.deviceId;\n            deviceName = device.name || 'Heart Rate Monitor';\n        } catch (error) {\n            console.error('Error requesting Heart Rate device:', error);\n            throw error;\n        }\n    } else {\n        deviceName = 'Restored HR Monitor';\n    }\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!deviceId) return;\n        await BleClient.connect(deviceId, onDisconnect);\n        connectionStorage.saveId('heartrate', deviceId);\n        notifyStatus('connected');\n\n        await BleClient.startNotifications(deviceId, HEART_RATE_SERVICE, HEART_RATE_MEASUREMENT, (value) => {\n            BluetoothDebugService.log(deviceName, value);\n            const flags = value.getUint8(0);\n            let heartRate: number;\n\n            // Check Heart Rate Value Format bit (bit 0)\n            if (flags & 0x01) {\n                // UINT16\n                heartRate = value.getUint16(1, true); // little-endian\n            } else {\n                // UINT8\n                heartRate = value.getUint8(1);\n            }\n\n            const entry: Measurement = { timestamp: Date.now(), value: heartRate };\n            listeners.forEach((listener) => listener(entry));\n        });\n        reconnectAttempts = 0;\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Native Heart Rate sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Native Heart Rate sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Native Heart Rate sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Native Heart Rate sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    const onDisconnect = (disconnectedDeviceId: string) => {\n        if (disconnectedDeviceId === deviceId && !isManualDisconnect) {\n            console.log('Native Heart Rate sensor: Disconnected');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    };\n\n    await connect();\n\n    return {\n        disconnect: async () => {\n            isManualDisconnect = true;\n            if (deviceId) {\n                try {\n                    await BleClient.stopNotifications(deviceId, HEART_RATE_SERVICE, HEART_RATE_MEASUREMENT);\n                    await BleClient.disconnect(deviceId);\n                } catch (e) {\n                    console.error('Error disconnecting native bluetooth:', e);\n                }\n            }\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectCadenceNative = async (previousDeviceId?: string): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let deviceId: string | null = previousDeviceId || null;\n    let lastCrankRevs: number | null = null;\n    let lastCrankTime: number | null = null;\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let deviceName = 'Cadence Sensor';\n\n    await ensureBleInitialized();\n\n    if (!deviceId) {\n        try {\n            const device = await BleClient.requestDevice({\n                services: [CYCLING_SPEED_AND_CADENCE_SERVICE],\n                optionalServices: [CYCLING_SPEED_AND_CADENCE_SERVICE],\n            });\n            deviceId = device.deviceId;\n            deviceName = device.name || 'Cadence Sensor';\n        } catch (error) {\n            console.error('Error requesting Cadence device:', error);\n            throw error;\n        }\n    } else {\n        deviceName = 'Restored Cadence Sensor';\n    }\n\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!deviceId) return;\n        await BleClient.connect(deviceId, onDisconnect);\n        connectionStorage.saveId('cadence', deviceId);\n        notifyStatus('connected');\n\n        await BleClient.startNotifications(deviceId, CYCLING_SPEED_AND_CADENCE_SERVICE, CSC_MEASUREMENT, (value) => {\n            BluetoothDebugService.log(deviceName, value);\n            const flags = value.getUint8(0);\n\n            // Check if crank revolution data is present (bit 1 of flags)\n            if (flags & 0x02) {\n                let offset = 1; // Start after flags byte\n\n                // If wheel revolution data is present (bit 0), skip it (6 bytes: 4 for revs + 2 for time)\n                if (flags & 0x01) {\n                    offset = 7;\n                }\n\n                const crankRevs = value.getUint16(offset, true);\n                const crankTime = value.getUint16(offset + 2, true); // Units: 1/1024 seconds\n\n                // Calculate RPM from delta between measurements\n                if (lastCrankRevs !== null && lastCrankTime !== null) {\n                    let revDelta = crankRevs - lastCrankRevs;\n                    let timeDelta = crankTime - lastCrankTime;\n\n                    // Handle rollover (uint16 max is 65535)\n                    if (revDelta < 0) revDelta += 65536;\n                    if (timeDelta < 0) timeDelta += 65536;\n\n                    // Calculate RPM: (revolutions / time_in_seconds) * 60\n                    // Time is in 1/1024 seconds, so convert to seconds\n                    if (timeDelta > 0) {\n                        const timeInSeconds = timeDelta / 1024;\n                        const rpm = Math.round((revDelta / timeInSeconds) * 60);\n\n                        // Sanity check for reasonable cadence values\n                        if (rpm >= 0 && rpm < 300) {\n                            const entry: Measurement = { timestamp: Date.now(), value: rpm };\n                            listeners.forEach((listener) => listener(entry));\n                        }\n                    }\n                }\n\n                lastCrankRevs = crankRevs;\n                lastCrankTime = crankTime;\n            }\n        });\n        reconnectAttempts = 0;\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Native Cadence sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Native Cadence sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Native Cadence sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Native Cadence sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    const onDisconnect = (disconnectedDeviceId: string) => {\n        if (disconnectedDeviceId === deviceId && !isManualDisconnect) {\n            console.log('Native Cadence sensor: Disconnected');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    };\n\n    await connect();\n\n    return {\n        disconnect: async () => {\n            isManualDisconnect = true;\n            if (deviceId) {\n                try {\n                    await BleClient.stopNotifications(deviceId, CYCLING_SPEED_AND_CADENCE_SERVICE, CSC_MEASUREMENT);\n                    await BleClient.disconnect(deviceId);\n                } catch (e) {\n                    console.error('Error disconnecting native bluetooth:', e);\n                }\n            }\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectTreadmillNative = async (previousDeviceId?: string): Promise<TreadmillConnection> => {\n    const listeners: TreadmillListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let deviceId: string | null = previousDeviceId || null;\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let deviceName = 'Treadmill';\n\n    await ensureBleInitialized();\n\n    if (!deviceId) {\n        try {\n            const device = await BleClient.requestDevice({\n                services: [FITNESS_MACHINE_SERVICE],\n                optionalServices: [FITNESS_MACHINE_SERVICE],\n            });\n            deviceId = device.deviceId;\n            deviceName = device.name || 'Treadmill';\n        } catch (error) {\n            console.error('Error requesting Treadmill device:', error);\n            throw error;\n        }\n    } else {\n        deviceName = 'Restored Treadmill';\n    }\n\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const onDisconnect = (disconnectedDeviceId: string) => {\n        if (disconnectedDeviceId === deviceId && !isManualDisconnect) {\n            console.log('Treadmill: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!deviceId) return;\n        await BleClient.connect(deviceId, onDisconnect);\n        connectionStorage.saveId('treadmill', deviceId);\n        notifyStatus('connected');\n\n        await BleClient.startNotifications(\n            deviceId,\n            FITNESS_MACHINE_SERVICE,\n            TREADMILL_DATA_CHARACTERISTIC,\n            (value) => {\n                BluetoothDebugService.log(deviceName, value);\n                try {\n                    const ftmsData = parseTreadmillData(value);\n\n                    if (ftmsData.speed !== undefined || ftmsData.incline !== undefined) {\n                        const entry: TreadmillMeasurement = {\n                            timestamp: Date.now(),\n                            speed: ftmsData.speed ?? null,\n                            incline: ftmsData.incline ?? null,\n                        };\n                        listeners.forEach((listener) => listener(entry));\n                    }\n                } catch (e) {\n                    console.error('Error parsing treadmill data', e);\n                }\n            }\n        );\n        reconnectAttempts = 0;\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect) return;\n\n        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            console.error('Treadmill: Max reconnection attempts reached');\n            notifyStatus('failed');\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Treadmill: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Treadmill: Reconnected successfully');\n        } catch (error) {\n            console.error('Treadmill: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    try {\n        await connect();\n    } catch (error) {\n        if (deviceId) {\n            try {\n                await BleClient.disconnect(deviceId);\n            } catch (e) {\n                /* ignore */\n            }\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: async () => {\n            isManualDisconnect = true;\n            if (deviceId) {\n                try {\n                    await BleClient.stopNotifications(deviceId, FITNESS_MACHINE_SERVICE, TREADMILL_DATA_CHARACTERISTIC);\n                    await BleClient.disconnect(deviceId);\n                } catch (e) {\n                    console.error('Error disconnecting treadmill', e);\n                }\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: TreadmillListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n","import type {\n    SensorConnection,\n    TreadmillConnection,\n    RowerConnection,\n    CrossTrainerConnection,\n    IndoorBikeConnection,\n    StepClimberConnection,\n    WeightScaleConnection,\n    RscConnection,\n    CscConnection,\n    MeasurementListener,\n    TreadmillListener,\n    RowerListener,\n    CrossTrainerListener,\n    IndoorBikeListener,\n    StepClimberListener,\n    WeightListener,\n    RscListener,\n    ConnectionStatusListener,\n    ConnectionStatus,\n} from '../../types/bluetooth.js';\nimport type {\n    Measurement,\n    TreadmillMeasurement,\n    RowerMeasurement,\n    CrossTrainerMeasurement,\n    IndoorBikeMeasurement,\n    StepClimberMeasurement,\n    WeightMeasurement,\n    RscMeasurement,\n} from '../../types/measurements.js';\nimport { connectionStorage } from '../../storage/connectionStorage.js';\nimport {\n    parseTreadmillData,\n    parseRowerData,\n    parseCrossTrainerData,\n    parseIndoorBikeData,\n    parseStepClimberData,\n    parseRscData,\n} from './ftms.js';\nimport { getSettings } from '../../config/settings.js';\nimport { BluetoothDebugService } from '../debug/BluetoothDebugService.js';\n\n/** Maximum reconnection attempts before giving up */\nconst MAX_RECONNECT_ATTEMPTS = 5;\n/** Base delay between reconnection attempts (ms) */\nconst RECONNECT_BASE_DELAY = 1000;\n\nexport const connectPowerWeb = async (previousDeviceId?: string): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let device: BluetoothDevice | undefined;\n\n    if (previousDeviceId && typeof navigator.bluetooth.getDevices === 'function') {\n        try {\n            const devices = await navigator.bluetooth.getDevices();\n            device = devices.find((d) => d.id === previousDeviceId);\n        } catch (e) {\n            console.warn('Failed to get permitted devices', e);\n        }\n    }\n\n    if (!device) {\n        if (previousDeviceId) {\n            throw new Error('Device not found in permitted list');\n        }\n\n        // Request Bluetooth device with cycling power service\n        device = await navigator.bluetooth.requestDevice({\n            filters: [{ services: ['cycling_power'] }],\n            optionalServices: ['cycling_power'],\n        });\n    }\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    if (device.id) {\n        connectionStorage.saveId('power', device.id);\n    }\n    const deviceName = device.name || 'Power Sensor';\n\n    /**\n     * Notify status listeners of connection status change\n     */\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    /**\n     * Handle characteristic value changes\n     */\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        // Cycling power measurement format: bytes 2-3 contain instantaneous power (little-endian)\n        const power = value.getInt16(2, true);\n        const entry: Measurement = { timestamp: Date.now(), value: power };\n        listeners.forEach((listener) => listener(entry));\n    };\n\n    /**\n     * Connect to the device and set up notifications\n     */\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        const server = await device.gatt.connect();\n        const service = await server.getPrimaryService('cycling_power');\n        characteristic = await service.getCharacteristic('cycling_power_measurement');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    /**\n     * Attempt to reconnect with exponential backoff\n     */\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Power sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Power sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Power sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Power sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    // Handle disconnection events\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Power sensor: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    // Initial connection\n    await connect();\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                characteristic.stopNotifications().catch(() => {});\n            }\n            device.gatt?.disconnect();\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectHeartRateWeb = async (previousDeviceId?: string): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let device: BluetoothDevice | undefined;\n\n    if (previousDeviceId && typeof navigator.bluetooth.getDevices === 'function') {\n        try {\n            const devices = await navigator.bluetooth.getDevices();\n            device = devices.find((d) => d.id === previousDeviceId);\n        } catch (e) {\n            console.warn('Failed to get permitted devices', e);\n        }\n    }\n\n    if (!device) {\n        if (previousDeviceId) {\n            throw new Error('Device not found in permitted list');\n        }\n\n        // Request Bluetooth device with heart rate service\n        device = await navigator.bluetooth.requestDevice({\n            filters: [{ services: ['heart_rate'] }],\n            optionalServices: ['heart_rate'],\n        });\n    }\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    if (device.id) {\n        connectionStorage.saveId('heartrate', device.id);\n    }\n    const deviceName = device.name || 'Heart Rate Monitor';\n\n    /**\n     * Notify status listeners of connection status change\n     */\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    /**\n     * Handle characteristic value changes\n     */\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        const flags = value.getUint8(0);\n        let heartRate: number;\n\n        // Check Heart Rate Value Format bit (bit 0)\n        if (flags & 0x01) {\n            // UINT16\n            heartRate = value.getUint16(1, true); // little-endian\n        } else {\n            // UINT8\n            heartRate = value.getUint8(1);\n        }\n\n        const entry: Measurement = { timestamp: Date.now(), value: heartRate };\n        listeners.forEach((listener) => listener(entry));\n    };\n\n    /**\n     * Connect to the device and set up notifications\n     */\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        const server = await device.gatt.connect();\n        const service = await server.getPrimaryService('heart_rate');\n        characteristic = await service.getCharacteristic('heart_rate_measurement');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    /**\n     * Attempt to reconnect with exponential backoff\n     */\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Heart rate sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Heart rate sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Heart rate sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Heart rate sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    // Handle disconnection events\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Heart rate sensor: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    // Initial connection\n    await connect();\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                characteristic.stopNotifications().catch(() => {});\n            }\n            device.gatt?.disconnect();\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectCadenceWeb = async (previousDeviceId?: string): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let lastCrankRevs: number | null = null;\n    let lastCrankTime: number | null = null;\n    let device: BluetoothDevice | undefined;\n\n    if (previousDeviceId && typeof navigator.bluetooth.getDevices === 'function') {\n        try {\n            const devices = await navigator.bluetooth.getDevices();\n            device = devices.find((d) => d.id === previousDeviceId);\n        } catch (e) {\n            console.warn('Failed to get permitted devices', e);\n        }\n    }\n\n    if (!device) {\n        if (previousDeviceId) {\n            throw new Error('Device not found in permitted list');\n        }\n\n        // Request Bluetooth device with cycling speed and cadence service\n        device = await navigator.bluetooth.requestDevice({\n            filters: [{ services: ['cycling_speed_and_cadence'] }],\n            optionalServices: ['cycling_speed_and_cadence'],\n        });\n    }\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    if (device.id) {\n        connectionStorage.saveId('cadence', device.id);\n    }\n    const deviceName = device.name || 'Cadence Sensor';\n\n    /**\n     * Notify status listeners of connection status change\n     */\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    /**\n     * Handle characteristic value changes\n     */\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        const flags = value.getUint8(0);\n\n        // Check if crank revolution data is present (bit 1 of flags)\n        if (flags & 0x02) {\n            // Crank revolution data format:\n            // - Cumulative Crank Revolutions (uint16, bytes 1-2 or 5-6 depending on wheel data)\n            // - Last Crank Event Time (uint16, bytes 3-4 or 7-8, units: 1/1024 seconds)\n\n            let offset = 1; // Start after flags byte\n\n            // If wheel revolution data is present (bit 0), skip it (6 bytes: 4 for revs + 2 for time)\n            if (flags & 0x01) {\n                offset = 7;\n            }\n\n            const crankRevs = value.getUint16(offset, true);\n            const crankTime = value.getUint16(offset + 2, true); // Units: 1/1024 seconds\n\n            // Calculate RPM from delta between measurements\n            if (lastCrankRevs !== null && lastCrankTime !== null) {\n                let revDelta = crankRevs - lastCrankRevs;\n                let timeDelta = crankTime - lastCrankTime;\n\n                // Handle rollover (uint16 max is 65535)\n                if (revDelta < 0) revDelta += 65536;\n                if (timeDelta < 0) timeDelta += 65536;\n\n                // Calculate RPM: (revolutions / time_in_seconds) * 60\n                // Time is in 1/1024 seconds, so convert to seconds\n                if (timeDelta > 0) {\n                    const timeInSeconds = timeDelta / 1024;\n                    const rpm = Math.round((revDelta / timeInSeconds) * 60);\n\n                    // Sanity check for reasonable cadence values\n                    if (rpm >= 0 && rpm < 300) {\n                        const entry: Measurement = { timestamp: Date.now(), value: rpm };\n                        listeners.forEach((listener) => listener(entry));\n                    }\n                }\n            }\n\n            lastCrankRevs = crankRevs;\n            lastCrankTime = crankTime;\n        }\n    };\n\n    /**\n     * Connect to the device and set up notifications\n     */\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        const server = await device.gatt.connect();\n        const service = await server.getPrimaryService('cycling_speed_and_cadence');\n        characteristic = await service.getCharacteristic('csc_measurement');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    /**\n     * Attempt to reconnect with exponential backoff\n     */\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Cadence sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Cadence sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Cadence sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Cadence sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    // Handle disconnection events\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Cadence sensor: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    // Initial connection\n    await connect();\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                characteristic.stopNotifications().catch(() => {});\n            }\n            device.gatt?.disconnect();\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectTreadmillWeb = async (previousDeviceId?: string): Promise<TreadmillConnection> => {\n    const listeners: TreadmillListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n    let device: BluetoothDevice | undefined;\n\n    if (previousDeviceId && typeof navigator.bluetooth.getDevices === 'function') {\n        try {\n            const devices = await navigator.bluetooth.getDevices();\n            device = devices.find((d) => d.id === previousDeviceId);\n        } catch (e) {\n            console.warn('Failed to get permitted devices', e);\n        }\n    }\n\n    if (!device) {\n        if (previousDeviceId) {\n            throw new Error('Device not found in permitted list');\n        }\n\n        // Request Bluetooth device with Fitness Machine Service\n        device = await navigator.bluetooth.requestDevice({\n            filters: [{ services: ['fitness_machine'] }],\n            optionalServices: ['fitness_machine'],\n        });\n    }\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    if (device.id) {\n        connectionStorage.saveId('treadmill', device.id);\n    }\n    const deviceName = device.name || 'Treadmill';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        try {\n            const ftmsData = parseTreadmillData(value);\n\n            // Only emit if we have relevant data\n            if (ftmsData.speed !== undefined || ftmsData.incline !== undefined) {\n                const entry: TreadmillMeasurement = {\n                    timestamp: Date.now(),\n                    speed: ftmsData.speed ?? null,\n                    incline: ftmsData.incline ?? null,\n                };\n                listeners.forEach((listener) => listener(entry));\n            }\n        } catch (e) {\n            console.error('Error parsing treadmill data', e);\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n        characteristic = await service.getCharacteristic('treadmill_data');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Treadmill: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Treadmill: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Treadmill: Reconnected successfully');\n        } catch (error) {\n            console.error('Treadmill: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Treadmill: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    // Initial connection\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch (e) {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: TreadmillListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectRowingWeb = async (): Promise<RowerConnection> => {\n    const listeners: RowerListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n\n    // Request Bluetooth device with Fitness Machine Service\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['fitness_machine'] }],\n        optionalServices: ['fitness_machine'],\n    });\n\n    const deviceName = device.name || 'Unknown Rower';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log('rower', value);\n\n        try {\n            const rowerData = parseRowerData(value);\n\n            const entry: RowerMeasurement = {\n                timestamp: Date.now(),\n                strokeRate: rowerData.strokeRate ?? null,\n                power: rowerData.instantaneousPower ?? null,\n            };\n            listeners.forEach((listener) => listener(entry));\n        } catch (e) {\n            console.error('Error parsing rower data', e);\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n        // 0x2AD1 is Rower Data\n        characteristic = await service.getCharacteristic('rower_data');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Rower: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Rower: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Rower: Reconnected successfully');\n        } catch (error) {\n            console.error('Rower: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Rower: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch (e) {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: RowerListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectConcept2 = async (): Promise<RowerConnection> => {\n    const listeners: RowerListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n\n    const C2_SERVICE_UUID = 'ce060030-43e5-11e4-916c-0800200c9a66';\n\n    // Request Bluetooth device with Fitness Machine Service\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ namePrefix: 'PM5' }],\n        optionalServices: [C2_SERVICE_UUID],\n    });\n\n    const deviceName = device.name || 'Unknown concept2 Rower';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log('concept2', value);\n\n        // Parsing logic would go here. For now just debug log is the priority.\n        const entry: RowerMeasurement = {\n            timestamp: Date.now(),\n            strokeRate: null,\n            power: null,\n        };\n        listeners.forEach((listener) => listener(entry));\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n        // 0x2AD1 is Rower Data\n        characteristic = await service.getCharacteristic('rower_data');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Rower: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Rower: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Rower: Reconnected successfully');\n        } catch (error) {\n            console.error('Rower: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Rower: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch (e) {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: RowerListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\n/**\n * Connect to CSC sensor with both speed and cadence support\n * Uses wheel circumference from settings to calculate speed\n */\nexport const connectCscWeb = async (): Promise<CscConnection> => {\n    const cadenceListeners: MeasurementListener[] = [];\n    const speedListeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n\n    // State for differential calculations\n    let lastCrankRevs: number | null = null;\n    let lastCrankTime: number | null = null;\n    let lastWheelRevs: number | null = null;\n    let lastWheelTime: number | null = null;\n\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['cycling_speed_and_cadence'] }],\n        optionalServices: ['cycling_speed_and_cadence'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Speed/Cadence Sensor';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        const flags = value.getUint8(0);\n        let offset = 1;\n\n        // Wheel Revolution Data Present (bit 0)\n        if (flags & 0x01) {\n            const wheelRevs = value.getUint32(offset, true);\n            offset += 4;\n            const wheelTime = value.getUint16(offset, true); // Units: 1/1024 seconds\n            offset += 2;\n\n            if (lastWheelRevs !== null && lastWheelTime !== null) {\n                let revDelta = wheelRevs - lastWheelRevs;\n                let timeDelta = wheelTime - lastWheelTime;\n\n                // Handle rollover\n                if (revDelta < 0) revDelta += 0x100000000; // uint32 max\n                if (timeDelta < 0) timeDelta += 65536;\n\n                if (timeDelta > 0 && revDelta > 0) {\n                    const timeInSeconds = timeDelta / 1024;\n                    const wheelCircumferenceMm = getSettings().wheelCircumferenceMm;\n                    // Speed in km/h: (revolutions * circumference_mm / 1000000) / time_seconds * 3600\n                    const speedKmh = ((revDelta * wheelCircumferenceMm) / 1000000 / timeInSeconds) * 3600;\n\n                    if (speedKmh >= 0 && speedKmh < 150) {\n                        const entry: Measurement = { timestamp: Date.now(), value: Math.round(speedKmh * 10) / 10 };\n                        speedListeners.forEach((listener) => listener(entry));\n                    }\n                }\n            }\n\n            lastWheelRevs = wheelRevs;\n            lastWheelTime = wheelTime;\n        }\n\n        // Crank Revolution Data Present (bit 1)\n        if (flags & 0x02) {\n            const crankRevs = value.getUint16(offset, true);\n            offset += 2;\n            const crankTime = value.getUint16(offset, true); // Units: 1/1024 seconds\n\n            if (lastCrankRevs !== null && lastCrankTime !== null) {\n                let revDelta = crankRevs - lastCrankRevs;\n                let timeDelta = crankTime - lastCrankTime;\n\n                if (revDelta < 0) revDelta += 65536;\n                if (timeDelta < 0) timeDelta += 65536;\n\n                if (timeDelta > 0) {\n                    const timeInSeconds = timeDelta / 1024;\n                    const rpm = Math.round((revDelta / timeInSeconds) * 60);\n\n                    if (rpm >= 0 && rpm < 300) {\n                        const entry: Measurement = { timestamp: Date.now(), value: rpm };\n                        cadenceListeners.forEach((listener) => listener(entry));\n                    }\n                }\n            }\n\n            lastCrankRevs = crankRevs;\n            lastCrankTime = crankTime;\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        const server = await device.gatt.connect();\n        const service = await server.getPrimaryService('cycling_speed_and_cadence');\n        characteristic = await service.getCharacteristic('csc_measurement');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n        } catch {\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    await connect();\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                characteristic.stopNotifications().catch(() => {});\n            }\n            device.gatt?.disconnect();\n        },\n        addCadenceListener: (callback: MeasurementListener) => {\n            cadenceListeners.push(callback);\n        },\n        addSpeedListener: (callback: MeasurementListener) => {\n            speedListeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\n/**\n * Connect to Cross Trainer / Elliptical (FTMS 0x2ACE)\n */\nexport const connectCrossTrainerWeb = async (): Promise<CrossTrainerConnection> => {\n    const listeners: CrossTrainerListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['fitness_machine'] }],\n        optionalServices: ['fitness_machine'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Cross Trainer';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        try {\n            const data = parseCrossTrainerData(value);\n\n            const entry: CrossTrainerMeasurement = {\n                timestamp: Date.now(),\n                speed: data.speed ?? null,\n                stepRate: data.stepPerMinute ?? null,\n                totalSteps: data.strideCount ?? null,\n                resistanceLevel: data.resistanceLevel ?? null,\n                incline: data.incline ?? null,\n                power: data.instantaneousPower ?? null,\n            };\n            listeners.forEach((listener) => listener(entry));\n        } catch (e) {\n            console.error('Error parsing cross trainer data', e);\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n        // 0x2ACE is Cross Trainer Data\n        characteristic = await service.getCharacteristic(0x2ace);\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n        } catch {\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: CrossTrainerListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\n/**\n * Connect to Indoor Bike (FTMS 0x2AD2) with ERG mode support\n */\nexport const connectIndoorBikeWeb = async (): Promise<IndoorBikeConnection> => {\n    const listeners: IndoorBikeListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let controlPoint: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n    let simSupported = false;\n\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['fitness_machine'] }],\n        optionalServices: ['fitness_machine'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Indoor Bike';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        try {\n            const data = parseIndoorBikeData(value);\n\n            const entry: IndoorBikeMeasurement = {\n                timestamp: Date.now(),\n                speed: data.speed ?? null,\n                cadence: data.cadence ?? null,\n                resistanceLevel: data.resistanceLevel ?? null,\n                power: data.instantaneousPower ?? null,\n            };\n            listeners.forEach((listener) => listener(entry));\n        } catch (e) {\n            console.error('Error parsing indoor bike data', e);\n        }\n    };\n\n    /**\n     * Write to FTMS Control Point (0x2AD9)\n     * OpCode 0x05 = Set Target Power (ERG mode)\n     * OpCode 0x04 = Set Target Resistance Level\n     */\n    const writeControlPoint = async (opCode: number, value: number): Promise<void> => {\n        if (!controlPoint) {\n            throw new Error('Control point not available');\n        }\n\n        const buffer = new ArrayBuffer(3);\n        const view = new DataView(buffer);\n        view.setUint8(0, opCode);\n        view.setInt16(1, value, true);\n\n        await controlPoint.writeValue(buffer);\n    };\n\n    /**\n     * Write Simulation Parameters (OpCode 0x11)\n     * @param windSpeed Wind Speed in m/s\n     * @param grade Grade in %\n     * @param crr Coefficient of Rolling Resistance (dimensionless)\n     * @param cw Coefficient of Aerodynamic Drag (kg/m)\n     */\n    const writeSimulationParameters = async (\n        windSpeed: number,\n        grade: number,\n        crr: number,\n        cw: number\n    ): Promise<void> => {\n        if (!controlPoint) {\n            throw new Error('Control point not available');\n        }\n\n        const buffer = new ArrayBuffer(7);\n        const view = new DataView(buffer);\n        view.setUint8(0, 0x11); // OpCode\n        view.setInt16(1, Math.round(windSpeed * 1000), true); // Wind Speed (0.001 m/s)\n        view.setInt16(3, Math.round(grade * 100), true); // Grade (0.01 %)\n        view.setUint8(5, Math.round(crr * 10000)); // Crr (0.0001)\n        view.setUint8(6, Math.round(cw * 100)); // Cw (0.01 kg/m)\n\n        await controlPoint.writeValue(buffer);\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n\n        // Indoor Bike Data (0x2AD2)\n        characteristic = await service.getCharacteristic(0x2ad2);\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        // Read Fitness Machine Features (0x2ACC) to check for capabilities\n        try {\n            const featureChar = await service.getCharacteristic(0x2acc);\n            const value = await featureChar.readValue();\n            // Features field is first 4 bytes\n            const features = value.getUint32(0, true);\n            // Bit 13: Indoor Bike Simulation Parameters Supported\n            simSupported = (features & (1 << 13)) !== 0;\n            console.log(`Indoor Bike Features: ${features.toString(16)}, Sim Supported: ${simSupported}`);\n        } catch (e) {\n            console.warn('Failed to read fitness machine features', e);\n        }\n\n        // Try to get Control Point for ERG mode (optional)\n        try {\n            controlPoint = await service.getCharacteristic(0x2ad9);\n            // Enable indications on control point\n            await controlPoint.startNotifications();\n        } catch {\n            console.log('Indoor bike: Control point not available (ERG mode disabled)');\n            controlPoint = null;\n        }\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n        } catch {\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch {\n                    /* ignore */\n                }\n            }\n            if (controlPoint) {\n                try {\n                    controlPoint.stopNotifications();\n                } catch {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: IndoorBikeListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n        setTargetPower: controlPoint\n            ? async (watts: number) => {\n                  await writeControlPoint(0x05, watts);\n              }\n            : undefined,\n        setResistance: controlPoint\n            ? async (level: number) => {\n                  await writeControlPoint(0x04, level * 10); // 0.1 resolution\n              }\n            : undefined,\n        setSimulationParameters: controlPoint\n            ? async (windSpeed: number, grade: number, crr: number, cw: number) => {\n                  if (!simSupported) {\n                      console.warn('Indoor bike does not support simulation parameters');\n                      // We might still try, or throw? Warn is safer.\n                  }\n                  await writeSimulationParameters(windSpeed, grade, crr, cw);\n              }\n            : undefined,\n    };\n};\n\n/**\n * Connect to Weight Scale (Body Composition 0x181B or Weight Scale 0x181D)\n */\nexport const connectWeightScaleWeb = async (): Promise<WeightScaleConnection> => {\n    const listeners: WeightListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n\n    // Try body composition first, fall back to weight scale\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [\n            { services: [0x181b] }, // Body Composition\n            { services: [0x181d] }, // Weight Scale\n        ],\n        optionalServices: [0x181b, 0x181d],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Weight Scale';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const parseWeightMeasurement = (value: DataView): WeightMeasurement | null => {\n        const flags = value.getUint8(0);\n        let offset = 1;\n\n        // Bit 0: Measurement Units (0 = SI, 1 = Imperial)\n        const isImperial = (flags & 0x01) !== 0;\n        // Bit 1: Time Stamp Present\n        const hasTimestamp = (flags & 0x02) !== 0;\n        // Bit 2: User ID Present\n        const hasUserId = (flags & 0x04) !== 0;\n        // Bit 3: BMI and Height Present\n        const hasBmiHeight = (flags & 0x08) !== 0;\n\n        // Weight (uint16, resolution 0.005 kg or 0.01 lb)\n        let weight = value.getUint16(offset, true);\n        offset += 2;\n\n        if (isImperial) {\n            // Convert pounds to kg: lb * 0.01 * 0.453592\n            weight = weight * 0.01 * 0.453592;\n        } else {\n            // SI: value * 0.005 kg\n            weight = weight * 0.005;\n        }\n\n        // Skip timestamp if present (7 bytes)\n        if (hasTimestamp) {\n            offset += 7;\n        }\n\n        // Skip user ID if present (1 byte)\n        if (hasUserId) {\n            offset += 1;\n        }\n\n        let bmi: number | undefined;\n        if (hasBmiHeight && value.byteLength >= offset + 4) {\n            // BMI: uint16, resolution 0.1 kg/m\n            bmi = value.getUint16(offset, true) * 0.1;\n        }\n\n        return {\n            timestamp: Date.now(),\n            weight: Math.round(weight * 100) / 100, // Round to 2 decimal places\n            bmi,\n        };\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        try {\n            const measurement = parseWeightMeasurement(value);\n\n            if (measurement && measurement.weight > 0) {\n                listeners.forEach((listener) => listener(measurement));\n            }\n        } catch (e) {\n            console.error('Error parsing weight data', e);\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        const server = await device.gatt.connect();\n\n        // Try Body Composition service first\n        try {\n            const bcService = await server.getPrimaryService(0x181b);\n            characteristic = await bcService.getCharacteristic(0x2a9c); // Body Composition Measurement\n        } catch {\n            // Fall back to Weight Scale service\n            const wsService = await server.getPrimaryService(0x181d);\n            characteristic = await wsService.getCharacteristic(0x2a9d); // Weight Measurement\n        }\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n        } catch {\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    await connect();\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                characteristic.stopNotifications().catch(() => {});\n            }\n            device.gatt?.disconnect();\n        },\n        addListener: (callback: WeightListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\n/**\n * Connect to Step Climber (FTMS 0x2ACF)\n */\nexport const connectStepClimberWeb = async (): Promise<StepClimberConnection> => {\n    const listeners: StepClimberListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['fitness_machine'] }],\n        optionalServices: ['fitness_machine'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Step Climber';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        try {\n            const data = parseStepClimberData(value);\n\n            const entry: StepClimberMeasurement = {\n                timestamp: Date.now(),\n                ...data,\n                power: data.instantaneousPower ?? null,\n                stepCount: data.stepCount ?? null,\n                floors: data.floors ?? null,\n                stepRate: data.stepRate ?? null,\n            };\n            listeners.forEach((listener) => listener(entry));\n        } catch (e) {\n            console.error('Error parsing step climber data', e);\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n\n        // Step Climber Data (0x2ACF)\n        characteristic = await service.getCharacteristic(0x2acf);\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n        } catch {\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: StepClimberListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\n/**\n * Connect to Rower (FTMS 0x2AD1)\n */\nexport const connectRowerWeb = async (): Promise<RowerConnection> => {\n    const listeners: RowerListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['fitness_machine'] }],\n        optionalServices: ['fitness_machine'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Rower';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        try {\n            const data = parseRowerData(value);\n\n            const entry: RowerMeasurement = {\n                timestamp: Date.now(),\n                strokeRate: data.strokeRate ?? null,\n                power: data.instantaneousPower ?? null,\n            };\n            listeners.forEach((listener) => listener(entry));\n        } catch (e) {\n            console.error('Error parsing rower data', e);\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n\n        // Rower Data (0x2AD1)\n        characteristic = await service.getCharacteristic(0x2ad1);\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n        } catch {\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: RowerListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\n/**\n * Connect to Running Speed & Cadence Sensor (0x1814)\n */\nexport const connectRscWeb = async (): Promise<RscConnection> => {\n    const listeners: RscListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['running_speed_and_cadence'] }],\n        optionalServices: ['running_speed_and_cadence'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'RSC Sensor';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        try {\n            const data = parseRscData(value);\n\n            const entry: RscMeasurement = {\n                timestamp: Date.now(),\n                ...data,\n            };\n            listeners.forEach((listener) => listener(entry));\n        } catch (e) {\n            console.error('Error parsing RSC data', e);\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('running_speed_and_cadence');\n\n        // RSC Measurement (0x2A53)\n        characteristic = await service.getCharacteristic(0x2a53);\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n        } catch {\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: RscListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n","import { Capacitor } from '@capacitor/core';\nimport type {\n    SensorConnection,\n    TreadmillConnection,\n    RowerConnection,\n    CrossTrainerConnection,\n    IndoorBikeConnection,\n    WeightScaleConnection,\n    StepClimberConnection,\n    RscConnection,\n    CscConnection,\n} from '../../types/bluetooth.js';\nimport {\n    connectPowerNative,\n    connectHeartRateNative,\n    connectCadenceNative,\n    connectTreadmillNative,\n} from './native-bluetooth.js';\nimport {\n    connectPowerWeb,\n    connectHeartRateWeb,\n    connectCadenceWeb,\n    connectTreadmillWeb,\n    connectRowingWeb,\n    connectConcept2,\n    connectCscWeb,\n    connectCrossTrainerWeb,\n    connectIndoorBikeWeb,\n    connectWeightScaleWeb,\n    connectStepClimberWeb,\n    connectRscWeb,\n} from './web-bluetooth.js';\n\n/**\n * Bluetooth Factory\n *\n * Abstract factory for creating Bluetooth sensor connections.\n * Automatically selects the appropriate implementation (Web Bluetooth or Native)\n * based on the current platform.\n */\nexport const BluetoothFactory = {\n    /**\n     * Connect to a Power Meter\n     * @returns Promise resolving to a SensorConnection\n     */\n    connectPower: async (previousDeviceId?: string): Promise<SensorConnection> => {\n        if (typeof window !== 'undefined' && (window as any).useMockSensors) {\n            const { MockPowerSensor } = await import('./mock.js');\n            const sensor = new MockPowerSensor();\n            await sensor.connect();\n            (window as any).mockSensor = sensor;\n            return sensor;\n        }\n        if (Capacitor.isNativePlatform()) {\n            return connectPowerNative(previousDeviceId);\n        } else {\n            return connectPowerWeb(previousDeviceId);\n        }\n    },\n\n    /**\n     * Connect to a Heart Rate Monitor\n     * @returns Promise resolving to a SensorConnection\n     */\n    connectHeartRate: async (previousDeviceId?: string): Promise<SensorConnection> => {\n        if (typeof window !== 'undefined' && (window as any).useMockSensors) {\n            const { MockHeartrateSensor } = await import('./mock.js');\n            const sensor = new MockHeartrateSensor();\n            await sensor.connect();\n            (window as any).mockSensor = sensor;\n            return sensor;\n        }\n        if (Capacitor.isNativePlatform()) {\n            return connectHeartRateNative(previousDeviceId);\n        } else {\n            return connectHeartRateWeb(previousDeviceId);\n        }\n    },\n\n    /**\n     * Connect to a Cadence Sensor\n     * @returns Promise resolving to a SensorConnection\n     */\n    connectCadence: async (previousDeviceId?: string): Promise<SensorConnection> => {\n        if (typeof window !== 'undefined' && (window as any).useMockSensors) {\n            const { MockCadenceSensor } = await import('./mock.js');\n            const sensor = new MockCadenceSensor();\n            await sensor.connect();\n            (window as any).mockSensor = sensor;\n            return sensor;\n        }\n        if (Capacitor.isNativePlatform()) {\n            return connectCadenceNative(previousDeviceId);\n        } else {\n            return connectCadenceWeb(previousDeviceId);\n        }\n    },\n\n    /**\n     * Connect to a Speed Sensor (CSC)\n     * @returns Promise resolving to a CscConnection\n     */\n    connectSpeed: async (): Promise<CscConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native speed connection not implemented');\n        } else {\n            return connectCscWeb();\n        }\n    },\n\n    /**\n     * Connect to a Treadmill\n     * @returns Promise resolving to a TreadmillConnection\n     */\n    connectTreadmill: async (previousDeviceId?: string): Promise<TreadmillConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            return connectTreadmillNative(previousDeviceId);\n        } else {\n            return connectTreadmillWeb(previousDeviceId);\n        }\n    },\n\n    /**\n     * Connect to a Rowing Machine\n     * @returns Promise resolving to a RowerConnection\n     */\n    connectRowing: async (): Promise<RowerConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native rowing connection not implemented');\n        } else {\n            return connectRowingWeb();\n        }\n    },\n\n    /**\n     * Connect to a Concept2 Rower\n     * @returns Promise resolving to a RowerConnection\n     */\n    connectConcept2: async (): Promise<RowerConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native rowing connection not implemented');\n        } else {\n            return connectConcept2();\n        }\n    },\n\n    /**\n     * Connect to a Concept2 Ski Erg\n     * @returns Promise resolving to a RowerConnection (uses same protocol)\n     */\n    connectSkiErg: async (): Promise<RowerConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native ski erg connection not implemented');\n        } else {\n            return connectConcept2(); // Ski Erg uses same Concept2 protocol\n        }\n    },\n\n    /**\n     * Connect to a CSC Sensor with both speed and cadence support\n     * @returns Promise resolving to a CscConnection\n     */\n    connectCsc: async (): Promise<CscConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native CSC connection not implemented');\n        } else {\n            return connectCscWeb();\n        }\n    },\n\n    /**\n     * Connect to a Running Speed and Cadence (RSC) sensor / foot pod\n     * @returns Promise resolving to a SensorConnection with cadence listener\n     */\n    connectRunningSensor: async (): Promise<RscConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native RSC connection not implemented');\n        } else {\n            return connectRscWeb();\n        }\n    },\n\n    /**\n     * Connect to a Cross Trainer / Elliptical\n     * @returns Promise resolving to a CrossTrainerConnection\n     */\n    connectCrossTrainer: async (): Promise<CrossTrainerConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native cross trainer connection not implemented');\n        } else {\n            return connectCrossTrainerWeb();\n        }\n    },\n\n    /**\n     * Connect to an Indoor Bike (FTMS) with optional ERG mode\n     * @returns Promise resolving to an IndoorBikeConnection\n     */\n    connectIndoorBike: async (): Promise<IndoorBikeConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native indoor bike connection not implemented');\n        } else {\n            return connectIndoorBikeWeb();\n        }\n    },\n\n    /**\n     * Connect to a Bluetooth Weight Scale\n     * @returns Promise resolving to a WeightScaleConnection\n     */\n    /**\n     * Connect to a Bluetooth Weight Scale\n     * @returns Promise resolving to a WeightScaleConnection\n     */\n    connectWeightScale: async (): Promise<WeightScaleConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native weight scale connection not implemented');\n        } else {\n            return connectWeightScaleWeb();\n        }\n    },\n\n    /**\n     * Connect to a Step Climber\n     * @returns Promise resolving to a StepClimberConnection\n     */\n    connectStepClimber: async (): Promise<StepClimberConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native step climber connection not implemented');\n        } else {\n            return connectStepClimberWeb();\n        }\n    },\n};\n"],"file":"feature-bluetooth-BY8rQx0J.js"}