{"version":3,"file":"fitnessService-h4L75Pmn.js","sources":["../../src/services/fitnessService.ts"],"sourcesContent":["/**\n * Fitness Service\n *\n * Manages client-side calculation and storage of PMC (Fitness/Fatigue) metrics.\n *\n * @module services/fitnessService\n */\n\nimport { getPMCData, savePMCData, DailyPMC, getCompletedWorkouts } from '../storage/workoutStorage.js';\nimport { calculatePMCStep } from '../calculations/trainingLoad.js';\n\n/**\n * Recalculate PMC history from all stored workouts.\n *\n * This is an expensive operation and should be run:\n * 1. On first initialization of the feature\n * 2. If the user clears PMC data\n * 3. Potentially after syncing extensive history from cloud\n */\nexport async function recalculatePMC(): Promise<void> {\n    const workouts = await getCompletedWorkouts();\n    if (workouts.length === 0) return;\n\n    // 1. Map workouts to Daily TSS\n    // We need to parse summaries to get TSS, or calculate it if missing\n    // Since we are client-only, we assume we might need to calc TSS here if not stored.\n    // However, existing `StoredWorkout` might not have TSS in summary if it's old.\n\n    // Group by date\n    const dailyTSS = new Map<string, number>();\n\n    workouts.forEach((w) => {\n        const date = new Date(w.startTime).toISOString().split('T')[0];\n        let tss = 0;\n\n        // Try to get TSS from summary\n        // `w` is StoredWorkout, which has `measurements` but maybe not summary object\n        // StoredWorkout definition confirms `measurements` and `metadata` roughly via `ActiveWorkoutRecord` conversion?\n        // Wait, StoredWorkout in workoutStorage.ts has `id, startTime, measurements`. It might not have processed summary.\n        // We might need to iterate and calculate on the fly if needed.\n        // BUT, getCompletedWorkouts returns `StoredWorkout[]`.\n\n        // Let's assume we can get TSS from a property we start saving, OR we calc it.\n        // For now, let's assume we won't recalc TSS for ALL history instantly unless requested,\n        // as it requires iterating millions of measurement points.\n        // Simplification: We only support PMC for workouts that HAVE a calculated TSS stored.\n        // Future improvement: Background worker to calc TSS for old rides.\n\n        // Checking if \"summary\" exists on stored workout is tricky as StoredWorkout struct doesn't have it explicitly defined in my view earlier.\n        // Let's cast to any for now to check potential future prop.\n        const workoutAny = w as any;\n        if (workoutAny.summary && workoutAny.summary.trainingLoad) {\n            tss = workoutAny.summary.trainingLoad;\n        } else if (workoutAny.trainingLoad) {\n            // Direct prop\n            tss = workoutAny.trainingLoad;\n        }\n\n        if (tss > 0) {\n            dailyTSS.set(date, (dailyTSS.get(date) || 0) + tss);\n        }\n    });\n\n    if (dailyTSS.size === 0) {\n        // No TSS found.\n        return;\n    }\n\n    const sortedDates = Array.from(dailyTSS.keys()).sort();\n    const firstDate = new Date(sortedDates[0]);\n    const lastDate = new Date(); // Today\n\n    // Normalize to midnight UTC\n    firstDate.setUTCHours(0, 0, 0, 0);\n    lastDate.setUTCHours(0, 0, 0, 0);\n\n    const result: DailyPMC[] = [];\n    let prevCtl = 0;\n    let prevAtl = 0;\n\n    const curr = new Date(firstDate);\n    // Loop day by day\n    while (curr <= lastDate) {\n        const dateStr = curr.toISOString().split('T')[0];\n        const tss = dailyTSS.get(dateStr) || 0;\n\n        const { ctl, atl, tsb } = calculatePMCStep(prevCtl, prevAtl, tss);\n\n        result.push({\n            date: dateStr,\n            tss,\n            ctl: Number(ctl.toFixed(2)),\n            atl: Number(atl.toFixed(2)),\n            tsb: Number(tsb.toFixed(2)),\n        });\n\n        prevCtl = ctl;\n        prevAtl = atl;\n\n        curr.setUTCDate(curr.getUTCDate() + 1);\n    }\n\n    await savePMCData(result);\n}\n\n/**\n * Add a workout to the PMC.\n * Updates the current day and recalculates future days (if any, e.g. adding a past workout).\n */\nexport async function addWorkoutToPMC(workoutDate: Date, tss: number): Promise<void> {\n    if (tss <= 0) return;\n\n    const dateStr = workoutDate.toISOString().split('T')[0];\n\n    // Get existing history\n    let history = await getPMCData();\n\n    if (history.length === 0) {\n        // Initialize\n        await recalculatePMC();\n        // Check if recalculate handled it (if we just added the workout to storage before calling this)\n        // If this function is called AFTER storage, recalculatePMC might have picked it up if we called it.\n        // But usually we want incremental update.\n\n        // If still empty (meaning this is the first ever workout with TSS), handle it manually\n        history = await getPMCData();\n        if (history.length === 0) {\n            const { ctl, atl, tsb } = calculatePMCStep(0, 0, tss);\n            await savePMCData([\n                {\n                    date: dateStr,\n                    tss,\n                    ctl: Number(ctl.toFixed(2)),\n                    atl: Number(atl.toFixed(2)),\n                    tsb: Number(tsb.toFixed(2)),\n                },\n            ]);\n            return;\n        }\n    }\n\n    // Find index of the date\n    const idx = history.findIndex((h) => h.date === dateStr);\n\n    let needsExtension = false;\n    let startIdx = 0;\n\n    if (idx !== -1) {\n        // Update existing day\n        history[idx].tss += tss;\n        startIdx = idx;\n    } else {\n        // Insert new day or append?\n        // If date is after the last date in history\n        const last = history[history.length - 1];\n        const lastDate = new Date(last.date);\n        const newDate = new Date(dateStr);\n\n        if (newDate > lastDate) {\n            // We need to fill gap from lastDate+1 to newDate\n            needsExtension = true;\n            // logic below will handle extension\n            startIdx = history.length; // Start processing from where we append\n        } else if (newDate < new Date(history[0].date)) {\n            // Prepending... complicated, easiest to recalculate all\n            await recalculatePMC();\n            return;\n        } else {\n            // Inserting in middle... complicated gap filling, easiest to recalculate all\n            await recalculatePMC();\n            return;\n        }\n    }\n\n    // Incremental update from startIdx\n    // If we updated an existing day (idx!=-1), we need to recalc from there.\n    // If we are extending, we need to generate new days.\n\n    if (needsExtension) {\n        const last = history[history.length - 1];\n        let prevCtl = last.ctl;\n        let prevAtl = last.atl;\n\n        const curr = new Date(last.date);\n        curr.setUTCDate(curr.getUTCDate() + 1);\n        const target = new Date(dateStr);\n        const today = new Date();\n        today.setUTCHours(0, 0, 0, 0);\n\n        const EndDate = target > today ? target : today; // Extend at least to workout date, or today\n\n        const newEntries: DailyPMC[] = [];\n\n        while (curr <= EndDate) {\n            const dStr = curr.toISOString().split('T')[0];\n            const dTss = dStr === dateStr ? tss : 0;\n\n            const { ctl, atl, tsb } = calculatePMCStep(prevCtl, prevAtl, dTss);\n\n            newEntries.push({\n                date: dStr,\n                tss: dTss,\n                ctl: Number(ctl.toFixed(2)),\n                atl: Number(atl.toFixed(2)),\n                tsb: Number(tsb.toFixed(2)),\n            });\n            prevCtl = ctl;\n            prevAtl = atl;\n            curr.setUTCDate(curr.getUTCDate() + 1);\n        }\n\n        await savePMCData(newEntries);\n    } else {\n        // Recalculating forward from startIdx\n        // We updated TSS at startIdx. Now we must re-propagate CTL/ATL chains.\n\n        let prevCtl = startIdx > 0 ? history[startIdx - 1].ctl : 0;\n        let prevAtl = startIdx > 0 ? history[startIdx - 1].atl : 0;\n\n        const updates: DailyPMC[] = [];\n\n        for (let i = startIdx; i < history.length; i++) {\n            const day = history[i];\n            const { ctl, atl, tsb } = calculatePMCStep(prevCtl, prevAtl, day.tss);\n\n            day.ctl = Number(ctl.toFixed(2));\n            day.atl = Number(atl.toFixed(2));\n            day.tsb = Number(tsb.toFixed(2));\n\n            updates.push(day);\n\n            prevCtl = day.ctl;\n            prevAtl = day.atl;\n        }\n\n        await savePMCData(updates);\n    }\n}\n\n/**\n * Get formatted PMC data for chart.\n */\nexport async function getClientPMCData(): Promise<DailyPMC[]> {\n    let data = await getPMCData();\n    if (data.length === 0) {\n        // Try initial recalc\n        await recalculatePMC();\n        data = await getPMCData();\n    }\n    return data;\n}\n"],"names":["recalculatePMC","workouts","getCompletedWorkouts","dailyTSS","w","date","tss","workoutAny","sortedDates","firstDate","lastDate","result","prevCtl","prevAtl","curr","dateStr","ctl","atl","tsb","calculatePMCStep","savePMCData","addWorkoutToPMC","workoutDate","history","getPMCData","idx","h","needsExtension","startIdx","last","newDate","target","today","EndDate","newEntries","dStr","dTss","updates","i","day","getClientPMCData","data"],"mappings":"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"}