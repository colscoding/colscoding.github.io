{"version":3,"mappings":"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","names":["DB_NAME","STORE_NAME","COMPLETED_STORE","DEBUG_STORE","db","openDatabase","resolve","reject","request","event","database","debugStore","saveDebugLog","sensor","data","record","e","getDebugLogs","clearDebugLogs","saveActiveWorkout","measurements","startTime","clearActiveWorkout","loadActiveWorkout","saveCompletedWorkout","endTime","id","getWorkoutHistory","saveTimeout","pendingSave","throttledSave","delayMs","flushPendingSave","isIndexedDBSupported","archiveWorkout","active","hasRecoverableWorkout","getCompletedWorkouts","markWorkoutSynced","store","ExceptionCode","CapacitorException","message","code","getPlatformId","win","_a","_b","createCapacitor","capCustomPlatform","cap","Plugins","getPlatform","isNativePlatform","isPluginAvailable","pluginName","plugin","registeredPlugins","getPluginHeader","h","handleError","err","registerPlugin","jsImplementations","registeredPlugin","platform","pluginHeader","jsImplementation","loadPluginImplementation","createPluginMethod","impl","prop","methodHeader","m","options","callback","createPluginMethodWrapper","remove","wrapper","args","p","fn","addListener","removeListener","addListenerNative","eventName","call","callbackId","proxy","_","filePath","initCapacitorGlobal","Capacitor","WebPlugin","listenerFunc","firstListener","windowListener","listener","retainUntilConsumed","listeners","windowEventName","pluginEventName","msg","index","handle","arg","encode","str","decode","CapacitorCookiesPluginWeb","cookies","cookieMap","cookie","key","value","encodedKey","encodedValue","expires","path","domain","error","readBlobAsBase64","blob","reader","base64String","normalizeHttpHeaders","headers","originalKeys","k","acc","buildUrlParams","params","shouldEncode","accumulator","entry","item","buildRequestInit","extra","output","type","form","CapacitorHttpPluginWeb","requestInit","urlParams","url","response","contentType","responseType","SystemBarsStyle","SystemBarType","SystemBarsPluginWeb","SETTINGS_KEY","defaultAutoPauseSettings","defaultWorkoutMetadataSettings","defaultCountdownSettings","defaultAutoLapSettings","defaultVoiceMetrics","defaultEnhancedVoiceSettings","defaultIntervalsSettings","defaultSettings","getSettings","settingsJson","parsed","saveSettingsToStorage","settings","ScanMode","ConnectionPriority","numbersToDataView","dataViewToNumbers","numberToUUID","hexStringToDataView","hex","bin","i","c","isEmpty","buffer","dataViewToHexString","n","s","webUUIDToString","uuid","mapToObject","map","obj","toUint8Array","dataView","toHexString","BluetoothLe","__vitePreload","makeQueue","currentTask","getQueue","enabled","parseUUID","BleClientClass","result","displayStrings","resultInternal","deviceIds","services","deviceId","onDisconnect","connectionPriority","service","characteristic","writeValue","descriptor","filter","BleClient","parseTreadmillData","flags","offset","hasAverageSpeed","hasTotalDistance","hasInclination","rawSpeed","rawAvgSpeed","b0","b1","b2","rawDist","rawIncline","rawRamp","BluetoothDebugService","b","logs","CYCLING_POWER_SERVICE","CYCLING_POWER_MEASUREMENT","HEART_RATE_SERVICE","HEART_RATE_MEASUREMENT","CYCLING_SPEED_AND_CADENCE_SERVICE","CSC_MEASUREMENT","FITNESS_MACHINE_SERVICE","TREADMILL_DATA_CHARACTERISTIC","MAX_RECONNECT_ATTEMPTS","RECONNECT_BASE_DELAY","isBleInitialized","ensureBleInitialized","connectPowerNative","statusListeners","isManualDisconnect","reconnectAttempts","device","deviceName","notifyStatus","status","connect","power","attemptReconnect","delay","disconnectedDeviceId","connectHeartRateNative","heartRate","connectCadenceNative","lastCrankRevs","lastCrankTime","crankRevs","crankTime","revDelta","timeDelta","timeInSeconds","rpm","connectTreadmillNative","ftmsData","connectPowerWeb","handleCharacteristicChange","connectHeartRateWeb","connectCadenceWeb","connectTreadmillWeb","server","connectRowingWeb","connectConcept2","BluetoothFactory","MockPowerSensor","MockHeartrateSensor","MockCadenceSensor"],"ignoreList":[1,3,4,5,6,7,8],"sources":["../../src/storage/workoutStorage.ts","../../../../node_modules/.pnpm/@capacitor+core@8.0.0/node_modules/@capacitor/core/dist/index.js","../../src/config/settings.ts","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/definitions.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/conversion.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/plugin.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/queue.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/validators.js","../../../../node_modules/.pnpm/@capacitor-community+bluetooth-le@7.3.0_@capacitor+core@8.0.0/node_modules/@capacitor-community/bluetooth-le/dist/esm/bleClient.js","../../src/services/bluetooth/ftms.ts","../../src/services/debug/BluetoothDebugService.ts","../../src/services/bluetooth/native-bluetooth.ts","../../src/services/bluetooth/web-bluetooth.ts","../../src/services/bluetooth/factory.ts"],"sourcesContent":["/**\n * IndexedDB Storage for Workout Data\n *\n * Provides persistent storage for workout recordings using IndexedDB.\n * This ensures workout data survives page refreshes, crashes, and accidental closures.\n *\n * @module storage/workoutStorage\n */\n\nimport type {\n    MeasurementsData,\n    Measurement,\n    LapMarker,\n    GpsPoint,\n    TreadmillMeasurement,\n} from '../types/measurements.js';\n\nconst DB_NAME = 'BikeTrackerDB';\nconst DB_VERSION = 4; // Bump version for schema change\nconst STORE_NAME = 'activeWorkout';\nconst COMPLETED_STORE = 'completedWorkouts';\nconst DEBUG_STORE = 'rawDebugData';\n\n/**\n * Raw Debug Log Entry\n */\nexport interface DebugLogEntry {\n    id?: number;\n    timestamp: number;\n    sensor: string;\n    data: string; // Hex representation\n}\n\n/**\n * Stored workout data with metadata\n */\nexport interface StoredWorkout {\n    id: string;\n    startTime: number;\n    lastUpdated: number;\n    measurements: MeasurementsData;\n    isCompleted: boolean;\n    synced?: boolean;\n    syncedTime?: number;\n}\n\n/**\n * Active workout record for recovery\n */\nexport interface ActiveWorkoutRecord {\n    id: 'current';\n    startTime: number;\n    lastUpdated: number;\n    heartrate: Measurement[];\n    power: Measurement[];\n    cadence: Measurement[];\n    speed: Measurement[];\n    distance: Measurement[];\n    altitude: Measurement[];\n    gps: GpsPoint[];\n    treadmill: TreadmillMeasurement[];\n    laps: LapMarker[];\n}\n\nlet db: IDBDatabase | null = null;\n\n/**\n * Opens the IndexedDB database, creating stores if needed\n */\nexport async function openDatabase(): Promise<IDBDatabase> {\n    if (db) return db;\n\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n        request.onerror = () => {\n            console.error('Failed to open IndexedDB:', request.error);\n            reject(request.error);\n        };\n\n        request.onsuccess = () => {\n            db = request.result;\n            resolve(db);\n        };\n\n        request.onupgradeneeded = (event) => {\n            const database = (event.target as IDBOpenDBRequest).result;\n\n            // Store for the currently active workout (single record)\n            if (!database.objectStoreNames.contains(STORE_NAME)) {\n                database.createObjectStore(STORE_NAME, { keyPath: 'id' });\n            }\n\n            // Store for completed workouts (backup/history)\n            if (!database.objectStoreNames.contains(COMPLETED_STORE)) {\n                const completedStore = database.createObjectStore(COMPLETED_STORE, { keyPath: 'id' });\n                completedStore.createIndex('startTime', 'startTime', { unique: false });\n            }\n\n            // Store for raw debug data\n            if (!database.objectStoreNames.contains(DEBUG_STORE)) {\n                const debugStore = database.createObjectStore(DEBUG_STORE, { keyPath: 'id', autoIncrement: true });\n                debugStore.createIndex('timestamp', 'timestamp', { unique: false });\n                debugStore.createIndex('sensor', 'sensor', { unique: false });\n            }\n        };\n    });\n}\n\n/**\n * Save a raw debug log entry\n */\nexport async function saveDebugLog(sensor: string, data: string): Promise<void> {\n    try {\n        const database = await openDatabase();\n        const record: DebugLogEntry = {\n            timestamp: Date.now(),\n            sensor,\n            data,\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([DEBUG_STORE], 'readwrite');\n            const store = transaction.objectStore(DEBUG_STORE);\n            const request = store.add(record); // Using add since key is auto-increment\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not save debug log:', e);\n    }\n}\n\n/**\n * Get all debug logs\n */\nexport async function getDebugLogs(): Promise<DebugLogEntry[]> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([DEBUG_STORE], 'readonly');\n            const store = transaction.objectStore(DEBUG_STORE);\n            const index = store.index('timestamp');\n            const request = index.getAll();\n\n            request.onsuccess = () => resolve(request.result || []);\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not load debug logs:', e);\n        return [];\n    }\n}\n\n/**\n * Clear all debug logs\n */\nexport async function clearDebugLogs(): Promise<void> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([DEBUG_STORE], 'readwrite');\n            const store = transaction.objectStore(DEBUG_STORE);\n            const request = store.clear();\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not clear debug logs:', e);\n    }\n}\n\n/**\n * Saves the current workout state to IndexedDB\n */\nexport async function saveActiveWorkout(measurements: MeasurementsData, startTime: number | null): Promise<void> {\n    try {\n        const database = await openDatabase();\n\n        const record: ActiveWorkoutRecord = {\n            id: 'current',\n            startTime: startTime ?? Date.now(),\n            lastUpdated: Date.now(),\n            heartrate: measurements.heartrate,\n            power: measurements.power,\n            cadence: measurements.cadence,\n            speed: measurements.speed,\n            distance: measurements.distance,\n            altitude: measurements.altitude,\n            gps: measurements.gps,\n            treadmill: measurements.treadmill || [],\n            laps: measurements.laps || [],\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([STORE_NAME], 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.put(record);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not save active workout:', e);\n    }\n}\n\n/**\n * Clear the active workout from storage\n */\nexport async function clearActiveWorkout(): Promise<void> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([STORE_NAME], 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.delete('current');\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not clear active workout:', e);\n    }\n}\n\n/**\n * Load the active workout from storage\n */\nexport async function loadActiveWorkout(): Promise<ActiveWorkoutRecord | null> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([STORE_NAME], 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.get('current');\n\n            request.onsuccess = () => {\n                if (request.result) {\n                    // Normalize optional arrays if missing in older DB versions\n                    const record = request.result;\n                    if (!record.treadmill) record.treadmill = [];\n                    if (!record.laps) record.laps = [];\n                    resolve(record);\n                } else {\n                    resolve(null);\n                }\n            };\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not load active workout:', e);\n        return null;\n    }\n}\n\n/**\n * Save a completed workout to history\n */\nexport async function saveCompletedWorkout(\n    measurements: MeasurementsData,\n    startTime: number,\n    endTime: number\n): Promise<string> {\n    const id = `workout_${startTime}`;\n\n    try {\n        const database = await openDatabase();\n\n        const record: StoredWorkout = {\n            id,\n            startTime,\n            lastUpdated: endTime,\n            isCompleted: true,\n            measurements: { ...measurements }, // Clone\n            synced: false,\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([COMPLETED_STORE], 'readwrite');\n            const store = transaction.objectStore(COMPLETED_STORE);\n            const request = store.put(record);\n\n            request.onsuccess = () => resolve(id);\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.error('Failed to save completed workout:', e);\n        throw e;\n    }\n}\n\n/**\n * Get all completed workouts from history\n */\nexport async function getWorkoutHistory(): Promise<StoredWorkout[]> {\n    try {\n        const database = await openDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = database.transaction([COMPLETED_STORE], 'readonly');\n            const store = transaction.objectStore(COMPLETED_STORE);\n            const index = store.index('startTime');\n            // Get all, sorted by start time (newest first requires manual reverse or cursor)\n            const request = index.getAll();\n\n            request.onsuccess = () => {\n                // Return newest first\n                resolve((request.result || []).reverse());\n            };\n            request.onerror = () => reject(request.error);\n        });\n    } catch (e) {\n        console.warn('Could not load workout history:', e);\n        return [];\n    }\n}\n\n// Throttled save mechanism\nlet saveTimeout: ReturnType<typeof setTimeout> | null = null;\nlet pendingSave: { measurements: MeasurementsData; startTime: number | null } | null = null;\n\n// Allow a 3rd optional parameter for delay to satisfy legacy tests, even if ignored or treated differently\nexport const throttledSave = (measurements: MeasurementsData, startTime: number | null, delayMs?: number): void => {\n    pendingSave = { measurements, startTime };\n    if (!saveTimeout) {\n        saveTimeout = setTimeout(async () => {\n            if (pendingSave) {\n                await saveActiveWorkout(pendingSave.measurements, pendingSave.startTime);\n                pendingSave = null;\n            }\n            saveTimeout = null;\n        }, delayMs || 2000); // Use provided delay or default 2s\n    }\n};\n\nexport const flushPendingSave = async (): Promise<void> => {\n    if (saveTimeout) {\n        clearTimeout(saveTimeout);\n        saveTimeout = null;\n    }\n    if (pendingSave) {\n        await saveActiveWorkout(pendingSave.measurements, pendingSave.startTime);\n        pendingSave = null;\n    }\n};\n\nexport const isIndexedDBSupported = (): boolean => {\n    return typeof window !== 'undefined' && 'indexedDB' in window;\n};\n\n/**\n * Legacy API Support / Aliases\n */\n\nexport const archiveWorkout = async (): Promise<string | null> => {\n    // Ensure any pending throttled saves are written to DB first\n    await flushPendingSave();\n\n    const active = await loadActiveWorkout();\n    if (!active) return null;\n\n    await saveCompletedWorkout(\n        {\n            heartrate: active.heartrate,\n            power: active.power,\n            cadence: active.cadence,\n            speed: active.speed,\n            distance: active.distance,\n            altitude: active.altitude,\n            gps: active.gps,\n            treadmill: active.treadmill,\n            laps: active.laps,\n        },\n        active.startTime,\n        active.lastUpdated\n    );\n    await clearActiveWorkout();\n    return `workout_${active.startTime}`;\n};\n\nexport const hasRecoverableWorkout = async (): Promise<boolean> => {\n    const active = await loadActiveWorkout();\n    return !!active;\n};\n\nexport const getCompletedWorkouts = getWorkoutHistory; // Alias\n\nexport const markWorkoutSynced = async (id: string): Promise<void> => {\n    const db = await openDatabase();\n    return new Promise((resolve, reject) => {\n        const tx = db.transaction(COMPLETED_STORE, 'readwrite');\n        const store = tx.objectStore(COMPLETED_STORE);\n        const request = store.get(id);\n\n        request.onsuccess = () => {\n            const data = request.result as StoredWorkout;\n            if (data) {\n                data.synced = true;\n                data.syncedTime = Date.now();\n                store.put(data);\n                resolve();\n            } else {\n                reject(new Error('Workout not found'));\n            }\n        };\n        request.onerror = () => reject(request.error);\n    });\n};\n","/*! Capacitor: https://capacitorjs.com/ - MIT License */\nvar ExceptionCode;\n(function (ExceptionCode) {\n    /**\n     * API is not implemented.\n     *\n     * This usually means the API can't be used because it is not implemented for\n     * the current platform.\n     */\n    ExceptionCode[\"Unimplemented\"] = \"UNIMPLEMENTED\";\n    /**\n     * API is not available.\n     *\n     * This means the API can't be used right now because:\n     *   - it is currently missing a prerequisite, such as network connectivity\n     *   - it requires a particular platform or browser version\n     */\n    ExceptionCode[\"Unavailable\"] = \"UNAVAILABLE\";\n})(ExceptionCode || (ExceptionCode = {}));\nclass CapacitorException extends Error {\n    constructor(message, code, data) {\n        super(message);\n        this.message = message;\n        this.code = code;\n        this.data = data;\n    }\n}\nconst getPlatformId = (win) => {\n    var _a, _b;\n    if (win === null || win === void 0 ? void 0 : win.androidBridge) {\n        return 'android';\n    }\n    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {\n        return 'ios';\n    }\n    else {\n        return 'web';\n    }\n};\n\nconst createCapacitor = (win) => {\n    const capCustomPlatform = win.CapacitorCustomPlatform || null;\n    const cap = win.Capacitor || {};\n    const Plugins = (cap.Plugins = cap.Plugins || {});\n    const getPlatform = () => {\n        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);\n    };\n    const isNativePlatform = () => getPlatform() !== 'web';\n    const isPluginAvailable = (pluginName) => {\n        const plugin = registeredPlugins.get(pluginName);\n        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {\n            // JS implementation available for the current platform.\n            return true;\n        }\n        if (getPluginHeader(pluginName)) {\n            // Native implementation available.\n            return true;\n        }\n        return false;\n    };\n    const getPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName); };\n    const handleError = (err) => win.console.error(err);\n    const registeredPlugins = new Map();\n    const registerPlugin = (pluginName, jsImplementations = {}) => {\n        const registeredPlugin = registeredPlugins.get(pluginName);\n        if (registeredPlugin) {\n            console.warn(`Capacitor plugin \"${pluginName}\" already registered. Cannot register plugins twice.`);\n            return registeredPlugin.proxy;\n        }\n        const platform = getPlatform();\n        const pluginHeader = getPluginHeader(pluginName);\n        let jsImplementation;\n        const loadPluginImplementation = async () => {\n            if (!jsImplementation && platform in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations[platform] === 'function'\n                        ? (jsImplementation = await jsImplementations[platform]())\n                        : (jsImplementation = jsImplementations[platform]);\n            }\n            else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations['web'] === 'function'\n                        ? (jsImplementation = await jsImplementations['web']())\n                        : (jsImplementation = jsImplementations['web']);\n            }\n            return jsImplementation;\n        };\n        const createPluginMethod = (impl, prop) => {\n            var _a, _b;\n            if (pluginHeader) {\n                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);\n                if (methodHeader) {\n                    if (methodHeader.rtype === 'promise') {\n                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);\n                    }\n                    else {\n                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);\n                    }\n                }\n                else if (impl) {\n                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);\n                }\n            }\n            else if (impl) {\n                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);\n            }\n            else {\n                throw new CapacitorException(`\"${pluginName}\" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n            }\n        };\n        const createPluginMethodWrapper = (prop) => {\n            let remove;\n            const wrapper = (...args) => {\n                const p = loadPluginImplementation().then((impl) => {\n                    const fn = createPluginMethod(impl, prop);\n                    if (fn) {\n                        const p = fn(...args);\n                        remove = p === null || p === void 0 ? void 0 : p.remove;\n                        return p;\n                    }\n                    else {\n                        throw new CapacitorException(`\"${pluginName}.${prop}()\" is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n                    }\n                });\n                if (prop === 'addListener') {\n                    p.remove = async () => remove();\n                }\n                return p;\n            };\n            // Some flair \n            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;\n            Object.defineProperty(wrapper, 'name', {\n                value: prop,\n                writable: false,\n                configurable: false,\n            });\n            return wrapper;\n        };\n        const addListener = createPluginMethodWrapper('addListener');\n        const removeListener = createPluginMethodWrapper('removeListener');\n        const addListenerNative = (eventName, callback) => {\n            const call = addListener({ eventName }, callback);\n            const remove = async () => {\n                const callbackId = await call;\n                removeListener({\n                    eventName,\n                    callbackId,\n                }, callback);\n            };\n            const p = new Promise((resolve) => call.then(() => resolve({ remove })));\n            p.remove = async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            };\n            return p;\n        };\n        const proxy = new Proxy({}, {\n            get(_, prop) {\n                switch (prop) {\n                    // https://github.com/facebook/react/issues/20030\n                    case '$$typeof':\n                        return undefined;\n                    case 'toJSON':\n                        return () => ({});\n                    case 'addListener':\n                        return pluginHeader ? addListenerNative : addListener;\n                    case 'removeListener':\n                        return removeListener;\n                    default:\n                        return createPluginMethodWrapper(prop);\n                }\n            },\n        });\n        Plugins[pluginName] = proxy;\n        registeredPlugins.set(pluginName, {\n            name: pluginName,\n            proxy,\n            platforms: new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])]),\n        });\n        return proxy;\n    };\n    // Add in convertFileSrc for web, it will already be available in native context\n    if (!cap.convertFileSrc) {\n        cap.convertFileSrc = (filePath) => filePath;\n    }\n    cap.getPlatform = getPlatform;\n    cap.handleError = handleError;\n    cap.isNativePlatform = isNativePlatform;\n    cap.isPluginAvailable = isPluginAvailable;\n    cap.registerPlugin = registerPlugin;\n    cap.Exception = CapacitorException;\n    cap.DEBUG = !!cap.DEBUG;\n    cap.isLoggingEnabled = !!cap.isLoggingEnabled;\n    return cap;\n};\nconst initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));\n\nconst Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof global !== 'undefined'\n                ? global\n                : {});\nconst registerPlugin = Capacitor.registerPlugin;\n\n/**\n * Base class web plugins should extend.\n */\nclass WebPlugin {\n    constructor() {\n        this.listeners = {};\n        this.retainedEventArguments = {};\n        this.windowListeners = {};\n    }\n    addListener(eventName, listenerFunc) {\n        let firstListener = false;\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            this.listeners[eventName] = [];\n            firstListener = true;\n        }\n        this.listeners[eventName].push(listenerFunc);\n        // If we haven't added a window listener for this event and it requires one,\n        // go ahead and add it\n        const windowListener = this.windowListeners[eventName];\n        if (windowListener && !windowListener.registered) {\n            this.addWindowListener(windowListener);\n        }\n        if (firstListener) {\n            this.sendRetainedArgumentsForEvent(eventName);\n        }\n        const remove = async () => this.removeListener(eventName, listenerFunc);\n        const p = Promise.resolve({ remove });\n        return p;\n    }\n    async removeAllListeners() {\n        this.listeners = {};\n        for (const listener in this.windowListeners) {\n            this.removeWindowListener(this.windowListeners[listener]);\n        }\n        this.windowListeners = {};\n    }\n    notifyListeners(eventName, data, retainUntilConsumed) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            if (retainUntilConsumed) {\n                let args = this.retainedEventArguments[eventName];\n                if (!args) {\n                    args = [];\n                }\n                args.push(data);\n                this.retainedEventArguments[eventName] = args;\n            }\n            return;\n        }\n        listeners.forEach((listener) => listener(data));\n    }\n    hasListeners(eventName) {\n        var _a;\n        return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);\n    }\n    registerWindowListener(windowEventName, pluginEventName) {\n        this.windowListeners[pluginEventName] = {\n            registered: false,\n            windowEventName,\n            pluginEventName,\n            handler: (event) => {\n                this.notifyListeners(pluginEventName, event);\n            },\n        };\n    }\n    unimplemented(msg = 'not implemented') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);\n    }\n    unavailable(msg = 'not available') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);\n    }\n    async removeListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(listenerFunc);\n        this.listeners[eventName].splice(index, 1);\n        // If there are no more listeners for this type of event,\n        // remove the window listener\n        if (!this.listeners[eventName].length) {\n            this.removeWindowListener(this.windowListeners[eventName]);\n        }\n    }\n    addWindowListener(handle) {\n        window.addEventListener(handle.windowEventName, handle.handler);\n        handle.registered = true;\n    }\n    removeWindowListener(handle) {\n        if (!handle) {\n            return;\n        }\n        window.removeEventListener(handle.windowEventName, handle.handler);\n        handle.registered = false;\n    }\n    sendRetainedArgumentsForEvent(eventName) {\n        const args = this.retainedEventArguments[eventName];\n        if (!args) {\n            return;\n        }\n        delete this.retainedEventArguments[eventName];\n        args.forEach((arg) => {\n            this.notifyListeners(eventName, arg);\n        });\n    }\n}\n\nconst WebView = /*#__PURE__*/ registerPlugin('WebView');\n/******** END WEB VIEW PLUGIN ********/\n/******** COOKIES PLUGIN ********/\n/**\n * Safely web encode a string value (inspired by js-cookie)\n * @param str The string value to encode\n */\nconst encode = (str) => encodeURIComponent(str)\n    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n    .replace(/[()]/g, escape);\n/**\n * Safely web decode a string value (inspired by js-cookie)\n * @param str The string value to decode\n */\nconst decode = (str) => str.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\nclass CapacitorCookiesPluginWeb extends WebPlugin {\n    async getCookies() {\n        const cookies = document.cookie;\n        const cookieMap = {};\n        cookies.split(';').forEach((cookie) => {\n            if (cookie.length <= 0)\n                return;\n            // Replace first \"=\" with CAP_COOKIE to prevent splitting on additional \"=\"\n            let [key, value] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');\n            key = decode(key).trim();\n            value = decode(value).trim();\n            cookieMap[key] = value;\n        });\n        return cookieMap;\n    }\n    async setCookie(options) {\n        try {\n            // Safely Encoded Key/Value\n            const encodedKey = encode(options.key);\n            const encodedValue = encode(options.value);\n            // Clean & sanitize options\n            const expires = `; expires=${(options.expires || '').replace('expires=', '')}`; // Default is \"; expires=\"\n            const path = (options.path || '/').replace('path=', ''); // Default is \"path=/\"\n            const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : '';\n            document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}; ${domain};`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async deleteCookie(options) {\n        try {\n            document.cookie = `${options.key}=; Max-Age=0`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearCookies() {\n        try {\n            const cookies = document.cookie.split(';') || [];\n            for (const cookie of cookies) {\n                document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);\n            }\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearAllCookies() {\n        try {\n            await this.clearCookies();\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n}\nconst CapacitorCookies = registerPlugin('CapacitorCookies', {\n    web: () => new CapacitorCookiesPluginWeb(),\n});\n// UTILITY FUNCTIONS\n/**\n * Read in a Blob value and return it as a base64 string\n * @param blob The blob value to convert to a base64 string\n */\nconst readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n        const base64String = reader.result;\n        // remove prefix \"data:application/pdf;base64,\"\n        resolve(base64String.indexOf(',') >= 0 ? base64String.split(',')[1] : base64String);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(blob);\n});\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\nconst normalizeHttpHeaders = (headers = {}) => {\n    const originalKeys = Object.keys(headers);\n    const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());\n    const normalized = loweredKeys.reduce((acc, key, index) => {\n        acc[key] = headers[originalKeys[index]];\n        return acc;\n    }, {});\n    return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\nconst buildUrlParams = (params, shouldEncode = true) => {\n    if (!params)\n        return null;\n    const output = Object.entries(params).reduce((accumulator, entry) => {\n        const [key, value] = entry;\n        let encodedValue;\n        let item;\n        if (Array.isArray(value)) {\n            item = '';\n            value.forEach((str) => {\n                encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n                item += `${key}=${encodedValue}&`;\n            });\n            // last character will always be \"&\" so slice it off\n            item.slice(0, -1);\n        }\n        else {\n            encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n            item = `${key}=${encodedValue}`;\n        }\n        return `${accumulator}&${item}`;\n    }, '');\n    // Remove initial \"&\" from the reduce\n    return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\nconst buildRequestInit = (options, extra = {}) => {\n    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);\n    // Get the content-type\n    const headers = normalizeHttpHeaders(options.headers);\n    const type = headers['content-type'] || '';\n    // If body is already a string, then pass it through as-is.\n    if (typeof options.data === 'string') {\n        output.body = options.data;\n    }\n    // Build request initializers based off of content-type\n    else if (type.includes('application/x-www-form-urlencoded')) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(options.data || {})) {\n            params.set(key, value);\n        }\n        output.body = params.toString();\n    }\n    else if (type.includes('multipart/form-data') || options.data instanceof FormData) {\n        const form = new FormData();\n        if (options.data instanceof FormData) {\n            options.data.forEach((value, key) => {\n                form.append(key, value);\n            });\n        }\n        else {\n            for (const key of Object.keys(options.data)) {\n                form.append(key, options.data[key]);\n            }\n        }\n        output.body = form;\n        const headers = new Headers(output.headers);\n        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n        output.headers = headers;\n    }\n    else if (type.includes('application/json') || typeof options.data === 'object') {\n        output.body = JSON.stringify(options.data);\n    }\n    return output;\n};\n// WEB IMPLEMENTATION\nclass CapacitorHttpPluginWeb extends WebPlugin {\n    /**\n     * Perform an Http request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async request(options) {\n        const requestInit = buildRequestInit(options, options.webFetchExtra);\n        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n        const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n        const response = await fetch(url, requestInit);\n        const contentType = response.headers.get('content-type') || '';\n        // Default to 'text' responseType so no parsing happens\n        let { responseType = 'text' } = response.ok ? options : {};\n        // If the response content-type is json, force the response to be json\n        if (contentType.includes('application/json')) {\n            responseType = 'json';\n        }\n        let data;\n        let blob;\n        switch (responseType) {\n            case 'arraybuffer':\n            case 'blob':\n                blob = await response.blob();\n                data = await readBlobAsBase64(blob);\n                break;\n            case 'json':\n                data = await response.json();\n                break;\n            case 'document':\n            case 'text':\n            default:\n                data = await response.text();\n        }\n        // Convert fetch headers to Capacitor HttpHeaders\n        const headers = {};\n        response.headers.forEach((value, key) => {\n            headers[key] = value;\n        });\n        return {\n            data,\n            headers,\n            status: response.status,\n            url: response.url,\n        };\n    }\n    /**\n     * Perform an Http GET request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async get(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'GET' }));\n    }\n    /**\n     * Perform an Http POST request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async post(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'POST' }));\n    }\n    /**\n     * Perform an Http PUT request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async put(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PUT' }));\n    }\n    /**\n     * Perform an Http PATCH request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async patch(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));\n    }\n    /**\n     * Perform an Http DELETE request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async delete(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));\n    }\n}\nconst CapacitorHttp = registerPlugin('CapacitorHttp', {\n    web: () => new CapacitorHttpPluginWeb(),\n});\n/******** END HTTP PLUGIN ********/\n/******** SYSTEM BARS PLUGIN ********/\n/**\n * Available status bar styles.\n */\nvar SystemBarsStyle;\n(function (SystemBarsStyle) {\n    /**\n     * Light system bar content on a dark background.\n     *\n     * @since 8.0.0\n     */\n    SystemBarsStyle[\"Dark\"] = \"DARK\";\n    /**\n     * For dark system bar content on a light background.\n     *\n     * @since 8.0.0\n     */\n    SystemBarsStyle[\"Light\"] = \"LIGHT\";\n    /**\n     * The style is based on the device appearance or the underlying content.\n     * If the device is using Dark mode, the system bars content will be light.\n     * If the device is using Light mode, the system bars content will be dark.\n     *\n     * @since 8.0.0\n     */\n    SystemBarsStyle[\"Default\"] = \"DEFAULT\";\n})(SystemBarsStyle || (SystemBarsStyle = {}));\n/**\n * Available system bar types.\n */\nvar SystemBarType;\n(function (SystemBarType) {\n    /**\n     * The top status bar on both Android and iOS.\n     *\n     * @since 8.0.0\n     */\n    SystemBarType[\"StatusBar\"] = \"StatusBar\";\n    /**\n     * The navigation bar (or gesture bar on iOS) on both Android and iOS.\n     *\n     * @since 8.0.0\n     */\n    SystemBarType[\"NavigationBar\"] = \"NavigationBar\";\n})(SystemBarType || (SystemBarType = {}));\nclass SystemBarsPluginWeb extends WebPlugin {\n    async setStyle() {\n        this.unavailable('not available for web');\n    }\n    async setAnimation() {\n        this.unavailable('not available for web');\n    }\n    async show() {\n        this.unavailable('not available for web');\n    }\n    async hide() {\n        this.unavailable('not available for web');\n    }\n}\nconst SystemBars = registerPlugin('SystemBars', {\n    web: () => new SystemBarsPluginWeb(),\n});\n/******** END SYSTEM BARS PLUGIN ********/\n\nexport { Capacitor, CapacitorCookies, CapacitorException, CapacitorHttp, ExceptionCode, SystemBarType, SystemBars, SystemBarsStyle, WebPlugin, WebView, buildRequestInit, registerPlugin };\n//# sourceMappingURL=index.js.map\n","/**\n * Application Settings Configuration\n *\n * Manages data structure and persistence only.\n * UI logic is in ui/settings.ts.\n */\n\n/**\n * Auto-pause source metric options\n */\nexport type AutoPauseSource = 'speed' | 'power' | 'cadence';\n\n/**\n * Auto-pause settings\n */\nexport interface AutoPauseSettings {\n    /** Whether auto-pause is enabled */\n    enabled: boolean;\n    /** Which metric to monitor for auto-pause */\n    source: AutoPauseSource;\n    /** Threshold value below which to pause (in source units: km/h, watts, rpm) */\n    threshold: number;\n    /** Delay in seconds before pausing (debounce) */\n    delay: number;\n}\n\n/**\n * Workout metadata settings - controls post-workout prompts\n */\nexport interface WorkoutMetadataSettings {\n    /** Whether to prompt for workout title/notes after completion */\n    promptForNotes: boolean;\n    /** Whether to prompt for perceived exertion (RPE) after completion */\n    promptForExertion: boolean;\n}\n\n/**\n * Countdown settings - controls pre-workout countdown\n */\nexport interface CountdownSettings {\n    /** Countdown duration in seconds (0 = disabled, 3, 5, or 10) */\n    duration: 0 | 3 | 5 | 10;\n    /** Whether to play audio beep during countdown */\n    enableBeep: boolean;\n    /** Whether to use voice announcement during countdown */\n    enableVoice: boolean;\n}\n\n/**\n * Auto-lap trigger source\n */\nexport type AutoLapSource = 'distance' | 'time';\n\n/**\n * Auto-lap settings\n */\nexport interface AutoLapSettings {\n    /** Whether auto-lap is enabled */\n    enabled: boolean;\n    /** What triggers auto-lap */\n    source: AutoLapSource;\n    /** Distance interval in km (for distance-based auto-lap) */\n    distanceKm: number;\n    /** Time interval in minutes (for time-based auto-lap) */\n    timeMinutes: number;\n}\n\n/**\n * Metrics to include in voice announcements\n */\nexport interface VoiceAnnouncementMetrics {\n    /** Announce current power */\n    power: boolean;\n    /** Announce heart rate */\n    heartrate: boolean;\n    /** Announce cadence */\n    cadence: boolean;\n    /** Announce current speed */\n    speed: boolean;\n    /** Announce total distance */\n    distance: boolean;\n    /** Announce elapsed time */\n    time: boolean;\n}\n\n/**\n * Enhanced voice announcement settings\n */\nexport interface EnhancedVoiceSettings {\n    /** Time-based announcement interval in minutes (0 = disabled) */\n    timeIntervalMinutes: 0 | 1 | 5 | 10 | 15 | 30;\n    /** Distance-based announcement interval in km (0 = disabled) */\n    distanceIntervalKm: 0 | 1 | 5 | 10;\n    /** Which metrics to announce */\n    metrics: VoiceAnnouncementMetrics;\n    /** Speech rate (0.5 = slow, 1 = normal, 1.5 = fast, 2 = very fast) */\n    speechRate: 0.5 | 0.75 | 1 | 1.25 | 1.5 | 2;\n}\n\n/**\n * Intervals.icu integration settings\n */\nexport interface IntervalsSettings {\n    /** Whether integration is enabled */\n    enabled: boolean;\n    /** API Key (get from intervals.icu settings) */\n    apiKey: string;\n    /** Athlete ID (use 'i' for self) */\n    athleteId: string;\n    /** Whether to upload automatically after workout */\n    autoUpload: boolean;\n}\n\n/**\n * Application settings\n */\nexport interface AppSettings {\n    // Dashboard display settings\n    power: boolean;\n    cadence: boolean;\n    heartrate: boolean;\n    speed: boolean;\n    distance: boolean;\n    altitude: boolean;\n    treadmillSpeed: boolean;\n    power3s: boolean;\n\n    // Accessibility settings\n    highContrast: boolean;\n    colorblindPatterns: boolean;\n\n    // Voice Feedback settings\n    voiceEnabled: boolean;\n    voiceLaps: boolean;\n    voiceZones: boolean;\n\n    // Export format settings\n    exportTcx: boolean;\n    exportCsv: boolean;\n    exportJson: boolean;\n    exportFit: boolean;\n\n    // Auto-pause settings\n    autoPause: AutoPauseSettings;\n\n    // Workout metadata settings\n    workoutMetadata: WorkoutMetadataSettings;\n\n    // Countdown settings\n    countdown: CountdownSettings;\n\n    // Auto-lap settings\n    autoLap: AutoLapSettings;\n\n    // Enhanced voice announcement settings\n    enhancedVoice: EnhancedVoiceSettings;\n\n    // Intervals.icu integration settings\n    intervals: IntervalsSettings;\n\n    // Calorie estimation settings\n    weightKg: number;\n    showCalories: boolean;\n\n    // Debug settings\n    debugMode: boolean;\n}\n\n/** Storage key for settings */\nexport const SETTINGS_KEY = 'bpt-settings';\n\n/** Default auto-pause settings */\nexport const defaultAutoPauseSettings: AutoPauseSettings = {\n    enabled: false,\n    source: 'speed',\n    threshold: 3, // 3 km/h default\n    delay: 3, // 3 seconds delay before pausing\n};\n\n/** Default workout metadata settings */\nexport const defaultWorkoutMetadataSettings: WorkoutMetadataSettings = {\n    promptForNotes: true,\n    promptForExertion: true,\n};\n\n/** Default countdown settings */\nexport const defaultCountdownSettings: CountdownSettings = {\n    duration: 0, // Disabled by default\n    enableBeep: true,\n    enableVoice: false,\n};\n\n/** Default auto-lap settings */\nexport const defaultAutoLapSettings: AutoLapSettings = {\n    enabled: false,\n    source: 'distance',\n    distanceKm: 1, // 1 km default\n    timeMinutes: 5, // 5 minutes default\n};\n\n/** Default voice announcement metrics */\nexport const defaultVoiceMetrics: VoiceAnnouncementMetrics = {\n    power: true,\n    heartrate: true,\n    cadence: false,\n    speed: true,\n    distance: true,\n    time: true,\n};\n\n/** Default enhanced voice settings */\nexport const defaultEnhancedVoiceSettings: EnhancedVoiceSettings = {\n    timeIntervalMinutes: 0, // Disabled by default\n    distanceIntervalKm: 0, // Disabled by default\n    metrics: { ...defaultVoiceMetrics },\n    speechRate: 1,\n};\n\n/** Default Intervals.icu settings */\nexport const defaultIntervalsSettings: IntervalsSettings = {\n    enabled: false,\n    apiKey: '',\n    athleteId: 'i',\n    autoUpload: false,\n};\n\n/** Default settings */\nexport const defaultSettings: AppSettings = {\n    power: true,\n    cadence: true,\n    heartrate: true,\n    speed: true,\n    distance: true,\n    altitude: true,\n    treadmillSpeed: false,\n    power3s: false,\n    highContrast: false,\n    colorblindPatterns: false,\n    voiceEnabled: false,\n    voiceLaps: true,\n    voiceZones: true,\n    exportTcx: true,\n    exportCsv: true,\n    exportJson: false,\n    exportFit: false,\n    autoPause: { ...defaultAutoPauseSettings },\n    workoutMetadata: { ...defaultWorkoutMetadataSettings },\n    countdown: { ...defaultCountdownSettings },\n    autoLap: { ...defaultAutoLapSettings },\n    enhancedVoice: { ...defaultEnhancedVoiceSettings },\n    intervals: { ...defaultIntervalsSettings },\n    weightKg: 75,\n    showCalories: false,\n    debugMode: false,\n};\n\n/**\n * Get current settings from localStorage\n */\nexport function getSettings(): AppSettings {\n    const settingsJson = localStorage.getItem(SETTINGS_KEY);\n    if (settingsJson) {\n        const parsed = JSON.parse(settingsJson);\n        // Ensure all nested settings have all required fields (migration for existing users)\n        return {\n            ...defaultSettings,\n            ...parsed,\n            autoPause: {\n                ...defaultAutoPauseSettings,\n                ...(parsed.autoPause || {}),\n            },\n            workoutMetadata: {\n                ...defaultWorkoutMetadataSettings,\n                ...(parsed.workoutMetadata || {}),\n            },\n            countdown: {\n                ...defaultCountdownSettings,\n                ...(parsed.countdown || {}),\n            },\n            autoLap: {\n                ...defaultAutoLapSettings,\n                ...(parsed.autoLap || {}),\n            },\n            enhancedVoice: {\n                ...defaultEnhancedVoiceSettings,\n                ...(parsed.enhancedVoice || {}),\n                metrics: {\n                    ...defaultVoiceMetrics,\n                    ...(parsed.enhancedVoice?.metrics || {}),\n                },\n            },\n            intervals: {\n                ...defaultIntervalsSettings,\n                ...(parsed.intervals || {}),\n            },\n            weightKg: parsed.weightKg ?? 75,\n            showCalories: parsed.showCalories ?? false,\n        };\n    }\n    return { ...defaultSettings };\n}\n\n/**\n * Save settings to localStorage\n */\nexport function saveSettingsToStorage(settings: AppSettings): void {\n    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));\n    // Dispatch event so UI can react if needed (though UI usually initiates the save)\n    window.dispatchEvent(new CustomEvent('settings-changed'));\n}\n","/**\r\n * Android scan mode\r\n */\r\nexport var ScanMode;\r\n(function (ScanMode) {\r\n    /**\r\n     * Perform Bluetooth LE scan in low power mode. This mode is enforced if the scanning application is not in foreground.\r\n     * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_POWER\r\n     */\r\n    ScanMode[ScanMode[\"SCAN_MODE_LOW_POWER\"] = 0] = \"SCAN_MODE_LOW_POWER\";\r\n    /**\r\n     * Perform Bluetooth LE scan in balanced power mode. (default) Scan results are returned at a rate that provides a good trade-off between scan frequency and power consumption.\r\n     * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_BALANCED\r\n     */\r\n    ScanMode[ScanMode[\"SCAN_MODE_BALANCED\"] = 1] = \"SCAN_MODE_BALANCED\";\r\n    /**\r\n     * Scan using highest duty cycle. It's recommended to only use this mode when the application is running in the foreground.\r\n     * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_LATENCY\r\n     */\r\n    ScanMode[ScanMode[\"SCAN_MODE_LOW_LATENCY\"] = 2] = \"SCAN_MODE_LOW_LATENCY\";\r\n})(ScanMode || (ScanMode = {}));\r\n/**\r\n * Android connection priority used in `requestConnectionPriority`\r\n */\r\nexport var ConnectionPriority;\r\n(function (ConnectionPriority) {\r\n    /**\r\n     * Use the connection parameters recommended by the Bluetooth SIG. This is the default value if no connection parameter update is requested.\r\n     * https://developer.android.com/reference/android/bluetooth/BluetoothGatt#CONNECTION_PRIORITY_BALANCED\r\n     */\r\n    ConnectionPriority[ConnectionPriority[\"CONNECTION_PRIORITY_BALANCED\"] = 0] = \"CONNECTION_PRIORITY_BALANCED\";\r\n    /**\r\n     * Request a high priority, low latency connection. An application should only request high priority connection parameters to transfer large amounts of data over LE quickly. Once the transfer is complete, the application should request CONNECTION_PRIORITY_BALANCED connection parameters to reduce energy use.\r\n     * https://developer.android.com/reference/android/bluetooth/BluetoothGatt#CONNECTION_PRIORITY_HIGH\r\n     */\r\n    ConnectionPriority[ConnectionPriority[\"CONNECTION_PRIORITY_HIGH\"] = 1] = \"CONNECTION_PRIORITY_HIGH\";\r\n    /**\r\n     * Request low power, reduced data rate connection parameters.\r\n     * https://developer.android.com/reference/android/bluetooth/BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER\r\n     */\r\n    ConnectionPriority[ConnectionPriority[\"CONNECTION_PRIORITY_LOW_POWER\"] = 2] = \"CONNECTION_PRIORITY_LOW_POWER\";\r\n})(ConnectionPriority || (ConnectionPriority = {}));\r\n//# sourceMappingURL=definitions.js.map","/**\r\n * Convert an array of numbers into a DataView.\r\n */\r\nexport function numbersToDataView(value) {\r\n    return new DataView(Uint8Array.from(value).buffer);\r\n}\r\n/**\r\n * Convert a DataView into an array of numbers.\r\n */\r\nexport function dataViewToNumbers(value) {\r\n    return Array.from(new Uint8Array(value.buffer, value.byteOffset, value.byteLength));\r\n}\r\n/**\r\n * Convert a string into a DataView.\r\n */\r\nexport function textToDataView(value) {\r\n    return numbersToDataView(value.split('').map((s) => s.charCodeAt(0)));\r\n}\r\n/**\r\n * Convert a DataView into a string.\r\n */\r\nexport function dataViewToText(value) {\r\n    return String.fromCharCode(...dataViewToNumbers(value));\r\n}\r\n/**\r\n * Convert a 16 bit UUID into a 128 bit UUID string\r\n * @param value number, e.g. 0x180d\r\n * @return string, e.g. '0000180d-0000-1000-8000-00805f9b34fb'\r\n */\r\nexport function numberToUUID(value) {\r\n    return `0000${value.toString(16).padStart(4, '0')}-0000-1000-8000-00805f9b34fb`;\r\n}\r\n/**\r\n * Convert a string of hex into a DataView of raw bytes.\r\n * Note: characters other than [0-9a-fA-F] are ignored\r\n * @param hex string of values, e.g. \"00 01 02\" or \"000102\"\r\n * @return DataView of raw bytes\r\n */\r\nexport function hexStringToDataView(hex) {\r\n    const bin = [];\r\n    let i, c, isEmpty = 1, buffer = 0;\r\n    for (i = 0; i < hex.length; i++) {\r\n        c = hex.charCodeAt(i);\r\n        if ((c > 47 && c < 58) || (c > 64 && c < 71) || (c > 96 && c < 103)) {\r\n            buffer = (buffer << 4) ^ ((c > 64 ? c + 9 : c) & 15);\r\n            if ((isEmpty ^= 1)) {\r\n                bin.push(buffer & 0xff);\r\n            }\r\n        }\r\n    }\r\n    return numbersToDataView(bin);\r\n}\r\nexport function dataViewToHexString(value) {\r\n    return dataViewToNumbers(value)\r\n        .map((n) => {\r\n        let s = n.toString(16);\r\n        if (s.length == 1) {\r\n            s = '0' + s;\r\n        }\r\n        return s;\r\n    })\r\n        .join('');\r\n}\r\nexport function webUUIDToString(uuid) {\r\n    if (typeof uuid === 'string') {\r\n        return uuid;\r\n    }\r\n    else if (typeof uuid === 'number') {\r\n        return numberToUUID(uuid);\r\n    }\r\n    else {\r\n        throw new Error('Invalid UUID');\r\n    }\r\n}\r\nexport function mapToObject(map) {\r\n    const obj = {};\r\n    if (!map) {\r\n        return undefined;\r\n    }\r\n    map.forEach((value, key) => {\r\n        obj[key.toString()] = value;\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * Convert Data or Uint8Array to Uint8Array.\r\n * @param value DataView, Uint8Array, or undefined\r\n * @return Uint8Array or undefined\r\n */\r\nexport function toUint8Array(value) {\r\n    if (value === undefined) {\r\n        return undefined;\r\n    }\r\n    if (typeof value === 'string') {\r\n        const dataView = hexStringToDataView(value);\r\n        return new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength);\r\n    }\r\n    if (value instanceof DataView) {\r\n        return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);\r\n    }\r\n    return value; // Already Uint8Array\r\n}\r\n/**\r\n * Convert Data, Uint8Array, or string to hex string.\r\n * @param value DataView, Uint8Array, or undefined\r\n * @return hex string or undefined\r\n */\r\nexport function toHexString(value) {\r\n    if (value === undefined) {\r\n        return undefined;\r\n    }\r\n    if (value instanceof DataView) {\r\n        return dataViewToHexString(value);\r\n    }\r\n    // Uint8Array\r\n    return dataViewToHexString(new DataView(value.buffer, value.byteOffset, value.byteLength));\r\n}\r\n//# sourceMappingURL=conversion.js.map","import { registerPlugin } from '@capacitor/core';\r\nexport const BluetoothLe = registerPlugin('BluetoothLe', {\r\n    web: () => import('./web').then((m) => new m.BluetoothLeWeb()),\r\n});\r\n//# sourceMappingURL=plugin.js.map","const makeQueue = () => {\r\n    let currentTask = Promise.resolve();\r\n    // create a new promise so that errors can be bubbled\r\n    // up to the caller without being caught by the queue\r\n    return (fn) => new Promise((resolve, reject) => {\r\n        currentTask = currentTask\r\n            .then(() => fn())\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n};\r\nexport function getQueue(enabled) {\r\n    if (enabled) {\r\n        return makeQueue();\r\n    }\r\n    return (fn) => fn();\r\n}\r\n//# sourceMappingURL=queue.js.map","export function parseUUID(uuid) {\r\n    if (typeof uuid !== 'string') {\r\n        throw new Error(`Invalid UUID type ${typeof uuid}. Expected string.`);\r\n    }\r\n    uuid = uuid.toLowerCase();\r\n    const is128BitUuid = uuid.search(/^[0-9a-f]{8}\\b-[0-9a-f]{4}\\b-[0-9a-f]{4}\\b-[0-9a-f]{4}\\b-[0-9a-f]{12}$/) >= 0;\r\n    if (!is128BitUuid) {\r\n        throw new Error(`Invalid UUID format ${uuid}. Expected 128 bit string (e.g. \"0000180d-0000-1000-8000-00805f9b34fb\").`);\r\n    }\r\n    return uuid;\r\n}\r\n//# sourceMappingURL=validators.js.map","import { Capacitor } from '@capacitor/core';\r\nimport { dataViewToHexString, hexStringToDataView, toUint8Array, toHexString } from './conversion';\r\nimport { BluetoothLe } from './plugin';\r\nimport { getQueue } from './queue';\r\nimport { parseUUID } from './validators';\r\nclass BleClientClass {\r\n    constructor() {\r\n        this.scanListener = null;\r\n        this.eventListeners = new Map();\r\n        this.queue = getQueue(true);\r\n    }\r\n    enableQueue() {\r\n        this.queue = getQueue(true);\r\n    }\r\n    disableQueue() {\r\n        this.queue = getQueue(false);\r\n    }\r\n    async initialize(options) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.initialize(options);\r\n        });\r\n    }\r\n    async isEnabled() {\r\n        const enabled = await this.queue(async () => {\r\n            const result = await BluetoothLe.isEnabled();\r\n            return result.value;\r\n        });\r\n        return enabled;\r\n    }\r\n    async requestEnable() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.requestEnable();\r\n        });\r\n    }\r\n    async enable() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.enable();\r\n        });\r\n    }\r\n    async disable() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.disable();\r\n        });\r\n    }\r\n    async startEnabledNotifications(callback) {\r\n        await this.queue(async () => {\r\n            var _a;\r\n            const key = `onEnabledChanged`;\r\n            await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n            const listener = await BluetoothLe.addListener(key, (result) => {\r\n                callback(result.value);\r\n            });\r\n            this.eventListeners.set(key, listener);\r\n            await BluetoothLe.startEnabledNotifications();\r\n        });\r\n    }\r\n    async stopEnabledNotifications() {\r\n        await this.queue(async () => {\r\n            var _a;\r\n            const key = `onEnabledChanged`;\r\n            await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n            this.eventListeners.delete(key);\r\n            await BluetoothLe.stopEnabledNotifications();\r\n        });\r\n    }\r\n    async isLocationEnabled() {\r\n        const enabled = await this.queue(async () => {\r\n            const result = await BluetoothLe.isLocationEnabled();\r\n            return result.value;\r\n        });\r\n        return enabled;\r\n    }\r\n    async openLocationSettings() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.openLocationSettings();\r\n        });\r\n    }\r\n    async openBluetoothSettings() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.openBluetoothSettings();\r\n        });\r\n    }\r\n    async openAppSettings() {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.openAppSettings();\r\n        });\r\n    }\r\n    async setDisplayStrings(displayStrings) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.setDisplayStrings(displayStrings);\r\n        });\r\n    }\r\n    async requestDevice(options) {\r\n        options = options ? this.validateRequestBleDeviceOptions(options) : undefined;\r\n        const result = await this.queue(async () => {\r\n            const device = await BluetoothLe.requestDevice(options);\r\n            return device;\r\n        });\r\n        return result;\r\n    }\r\n    async requestLEScan(options, callback) {\r\n        options = this.validateRequestBleDeviceOptions(options);\r\n        await this.queue(async () => {\r\n            var _a;\r\n            await ((_a = this.scanListener) === null || _a === void 0 ? void 0 : _a.remove());\r\n            this.scanListener = await BluetoothLe.addListener('onScanResult', (resultInternal) => {\r\n                const result = Object.assign(Object.assign({}, resultInternal), { manufacturerData: this.convertObject(resultInternal.manufacturerData), serviceData: this.convertObject(resultInternal.serviceData), rawAdvertisement: resultInternal.rawAdvertisement\r\n                        ? this.convertValue(resultInternal.rawAdvertisement)\r\n                        : undefined });\r\n                callback(result);\r\n            });\r\n            await BluetoothLe.requestLEScan(options);\r\n        });\r\n    }\r\n    async stopLEScan() {\r\n        await this.queue(async () => {\r\n            var _a;\r\n            await ((_a = this.scanListener) === null || _a === void 0 ? void 0 : _a.remove());\r\n            this.scanListener = null;\r\n            await BluetoothLe.stopLEScan();\r\n        });\r\n    }\r\n    async getDevices(deviceIds) {\r\n        if (!Array.isArray(deviceIds)) {\r\n            throw new Error('deviceIds must be an array');\r\n        }\r\n        return this.queue(async () => {\r\n            const result = await BluetoothLe.getDevices({ deviceIds });\r\n            return result.devices;\r\n        });\r\n    }\r\n    async getConnectedDevices(services) {\r\n        if (!Array.isArray(services)) {\r\n            throw new Error('services must be an array');\r\n        }\r\n        services = services.map(parseUUID);\r\n        return this.queue(async () => {\r\n            const result = await BluetoothLe.getConnectedDevices({ services });\r\n            return result.devices;\r\n        });\r\n    }\r\n    async getBondedDevices() {\r\n        return this.queue(async () => {\r\n            const result = await BluetoothLe.getBondedDevices();\r\n            return result.devices;\r\n        });\r\n    }\r\n    async connect(deviceId, onDisconnect, options) {\r\n        await this.queue(async () => {\r\n            var _a;\r\n            if (onDisconnect) {\r\n                const key = `disconnected|${deviceId}`;\r\n                await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n                const listener = await BluetoothLe.addListener(key, () => {\r\n                    onDisconnect(deviceId);\r\n                });\r\n                this.eventListeners.set(key, listener);\r\n            }\r\n            await BluetoothLe.connect(Object.assign({ deviceId }, options));\r\n        });\r\n    }\r\n    async createBond(deviceId, options) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.createBond(Object.assign({ deviceId }, options));\r\n        });\r\n    }\r\n    async isBonded(deviceId) {\r\n        const isBonded = await this.queue(async () => {\r\n            const result = await BluetoothLe.isBonded({ deviceId });\r\n            return result.value;\r\n        });\r\n        return isBonded;\r\n    }\r\n    async disconnect(deviceId) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.disconnect({ deviceId });\r\n        });\r\n    }\r\n    async getServices(deviceId) {\r\n        const services = await this.queue(async () => {\r\n            const result = await BluetoothLe.getServices({ deviceId });\r\n            return result.services;\r\n        });\r\n        return services;\r\n    }\r\n    async discoverServices(deviceId) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.discoverServices({ deviceId });\r\n        });\r\n    }\r\n    async getMtu(deviceId) {\r\n        const value = await this.queue(async () => {\r\n            const result = await BluetoothLe.getMtu({ deviceId });\r\n            return result.value;\r\n        });\r\n        return value;\r\n    }\r\n    async requestConnectionPriority(deviceId, connectionPriority) {\r\n        await this.queue(async () => {\r\n            await BluetoothLe.requestConnectionPriority({ deviceId, connectionPriority });\r\n        });\r\n    }\r\n    async readRssi(deviceId) {\r\n        const value = await this.queue(async () => {\r\n            const result = await BluetoothLe.readRssi({ deviceId });\r\n            return parseFloat(result.value);\r\n        });\r\n        return value;\r\n    }\r\n    async read(deviceId, service, characteristic, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        const value = await this.queue(async () => {\r\n            const result = await BluetoothLe.read(Object.assign({ deviceId,\r\n                service,\r\n                characteristic }, options));\r\n            return this.convertValue(result.value);\r\n        });\r\n        return value;\r\n    }\r\n    async write(deviceId, service, characteristic, value, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        return this.queue(async () => {\r\n            if (!(value === null || value === void 0 ? void 0 : value.buffer)) {\r\n                throw new Error('Invalid data.');\r\n            }\r\n            let writeValue = value;\r\n            if (Capacitor.getPlatform() !== 'web') {\r\n                // on native we can only write strings\r\n                writeValue = dataViewToHexString(value);\r\n            }\r\n            await BluetoothLe.write(Object.assign({ deviceId,\r\n                service,\r\n                characteristic, value: writeValue }, options));\r\n        });\r\n    }\r\n    async writeWithoutResponse(deviceId, service, characteristic, value, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        await this.queue(async () => {\r\n            if (!(value === null || value === void 0 ? void 0 : value.buffer)) {\r\n                throw new Error('Invalid data.');\r\n            }\r\n            let writeValue = value;\r\n            if (Capacitor.getPlatform() !== 'web') {\r\n                // on native we can only write strings\r\n                writeValue = dataViewToHexString(value);\r\n            }\r\n            await BluetoothLe.writeWithoutResponse(Object.assign({ deviceId,\r\n                service,\r\n                characteristic, value: writeValue }, options));\r\n        });\r\n    }\r\n    async readDescriptor(deviceId, service, characteristic, descriptor, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        descriptor = parseUUID(descriptor);\r\n        const value = await this.queue(async () => {\r\n            const result = await BluetoothLe.readDescriptor(Object.assign({ deviceId,\r\n                service,\r\n                characteristic,\r\n                descriptor }, options));\r\n            return this.convertValue(result.value);\r\n        });\r\n        return value;\r\n    }\r\n    async writeDescriptor(deviceId, service, characteristic, descriptor, value, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        descriptor = parseUUID(descriptor);\r\n        return this.queue(async () => {\r\n            if (!(value === null || value === void 0 ? void 0 : value.buffer)) {\r\n                throw new Error('Invalid data.');\r\n            }\r\n            let writeValue = value;\r\n            if (Capacitor.getPlatform() !== 'web') {\r\n                // on native we can only write strings\r\n                writeValue = dataViewToHexString(value);\r\n            }\r\n            await BluetoothLe.writeDescriptor(Object.assign({ deviceId,\r\n                service,\r\n                characteristic,\r\n                descriptor, value: writeValue }, options));\r\n        });\r\n    }\r\n    async startNotifications(deviceId, service, characteristic, callback, options) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        await this.queue(async () => {\r\n            var _a;\r\n            const key = `notification|${deviceId}|${service}|${characteristic}`;\r\n            await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n            const listener = await BluetoothLe.addListener(key, (event) => {\r\n                callback(this.convertValue(event === null || event === void 0 ? void 0 : event.value));\r\n            });\r\n            this.eventListeners.set(key, listener);\r\n            await BluetoothLe.startNotifications(Object.assign({ deviceId,\r\n                service,\r\n                characteristic }, options));\r\n        });\r\n    }\r\n    async stopNotifications(deviceId, service, characteristic) {\r\n        service = parseUUID(service);\r\n        characteristic = parseUUID(characteristic);\r\n        await this.queue(async () => {\r\n            var _a;\r\n            const key = `notification|${deviceId}|${service}|${characteristic}`;\r\n            await ((_a = this.eventListeners.get(key)) === null || _a === void 0 ? void 0 : _a.remove());\r\n            this.eventListeners.delete(key);\r\n            await BluetoothLe.stopNotifications({\r\n                deviceId,\r\n                service,\r\n                characteristic,\r\n            });\r\n        });\r\n    }\r\n    validateRequestBleDeviceOptions(options) {\r\n        if (options.services) {\r\n            options.services = options.services.map(parseUUID);\r\n        }\r\n        if (options.optionalServices) {\r\n            options.optionalServices = options.optionalServices.map(parseUUID);\r\n        }\r\n        if (options.serviceData && Capacitor.getPlatform() !== 'web') {\r\n            // Native platforms: convert to hex strings\r\n            options.serviceData = options.serviceData.map((filter) => (Object.assign(Object.assign({}, filter), { serviceUuid: parseUUID(filter.serviceUuid), dataPrefix: toHexString(filter.dataPrefix), mask: toHexString(filter.mask) })));\r\n        }\r\n        if (options.manufacturerData) {\r\n            if (Capacitor.getPlatform() !== 'web') {\r\n                // Native platforms: convert to hex strings\r\n                options.manufacturerData = options.manufacturerData.map((filter) => (Object.assign(Object.assign({}, filter), { dataPrefix: toHexString(filter.dataPrefix), mask: toHexString(filter.mask) })));\r\n            }\r\n            else {\r\n                // Web platform: convert to Uint8Array for Web Bluetooth API\r\n                options.manufacturerData = options.manufacturerData.map((filter) => (Object.assign(Object.assign({}, filter), { dataPrefix: toUint8Array(filter.dataPrefix), mask: toUint8Array(filter.mask) })));\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n    convertValue(value) {\r\n        if (typeof value === 'string') {\r\n            return hexStringToDataView(value);\r\n        }\r\n        else if (value === undefined) {\r\n            return new DataView(new ArrayBuffer(0));\r\n        }\r\n        return value;\r\n    }\r\n    convertObject(obj) {\r\n        if (obj === undefined) {\r\n            return undefined;\r\n        }\r\n        const result = {};\r\n        for (const key of Object.keys(obj)) {\r\n            result[key] = this.convertValue(obj[key]);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexport const BleClient = new BleClientClass();\r\n//# sourceMappingURL=bleClient.js.map","/**\n * FTMS (Fitness Machine Service) Parser\n *\n * Handles parsing of Bluetooth LE data from Fitness Machines (Treadmills).\n *\n * Specs: https://www.bluetooth.com/specifications/specs/fitness-machine-service-1-0/\n */\n\nexport interface FTMSValues {\n    speed?: number; // km/h\n    averageSpeed?: number; // km/h\n    totalDistance?: number; // meters\n    incline?: number; // %\n    rampAngle?: number; // degrees\n}\n\n/**\n * Parses Treadmill Data characteristic (0x2ACD)\n *\n * @param data DataView containing the raw bytes\n * @returns Parsed values object\n */\nexport const parseTreadmillData = (data: DataView): FTMSValues => {\n    // Check flags in first 2 bytes (16-bit LE)\n    const flags = data.getUint16(0, true);\n    let offset = 2;\n    const result: FTMSValues = {};\n\n    // Bit 0: More Data (ignored for now)\n    // Bit 1: Average Speed Present\n    const hasAverageSpeed = (flags & (1 << 1)) !== 0;\n    // Bit 2: Total Distance Present\n    const hasTotalDistance = (flags & (1 << 2)) !== 0;\n    // Bit 3: Inclination and Ramp Angle Present\n    const hasInclination = (flags & (1 << 3)) !== 0;\n\n    // Other bits ignored for now to avoid unused variable warnings\n    /*\n    // Bit 4: Elevation Gain Present\n    const hasElevationGain = (flags & (1 << 4)) !== 0;\n    // Bit 5: Instantaneous Pace Present\n    const hasPace = (flags & (1 << 5)) !== 0;\n    // Bit 6: Average Pace Present\n    const hasAveragePace = (flags & (1 << 6)) !== 0;\n    // Bit 7: Expended Energy Present\n    const hasEnergy = (flags & (1 << 7)) !== 0;\n    // Bit 8: Heart Rate Present\n    const hasHeartRate = (flags & (1 << 8)) !== 0;\n    // Bit 9: Metabolic Equivalent Present\n    const hasMetabolic = (flags & (1 << 9)) !== 0;\n    // Bit 10: Elapsed Time Present\n    const hasElapsedTime = (flags & (1 << 10)) !== 0;\n    // Bit 11: Remaining Time Present\n    const hasRemainingTime = (flags & (1 << 11)) !== 0;\n    // Bit 12: Force on Belt and Power Output Present\n    const hasForcePower = (flags & (1 << 12)) !== 0;\n    */\n\n    // Instantaneous Speed (Always present unless noted otherwise, but spec says \"C1\" - Mandatory)\n    // Unit: 0.01 km/h, uint16\n    // Note: Some legacy devices might interpret flags differently, but standard says first field after flags is Inst. Speed.\n    if (data.byteLength >= offset + 2) {\n        const rawSpeed = data.getUint16(offset, true);\n        result.speed = rawSpeed / 100.0;\n        offset += 2;\n    }\n\n    if (hasAverageSpeed && data.byteLength >= offset + 2) {\n        const rawAvgSpeed = data.getUint16(offset, true);\n        result.averageSpeed = rawAvgSpeed / 100.0;\n        offset += 2;\n    }\n\n    if (hasTotalDistance && data.byteLength >= offset + 3) {\n        // unit24 is tricky. Read 3 bytes.\n        // Little endian: byte[0] + byte[1]<<8 + byte[2]<<16\n        const b0 = data.getUint8(offset);\n        const b1 = data.getUint8(offset + 1);\n        const b2 = data.getUint8(offset + 2);\n        const rawDist = b0 + (b1 << 8) + (b2 << 16);\n\n        result.totalDistance = rawDist;\n        offset += 3;\n    }\n\n    if (hasInclination && data.byteLength >= offset + 4) {\n        // Inclination: sint16, 0.1 %\n        const rawIncline = data.getInt16(offset, true);\n        result.incline = rawIncline / 10.0;\n        offset += 2;\n\n        // Ramp Angle: sint16, 0.1 degree\n        const rawRamp = data.getInt16(offset, true);\n        result.rampAngle = rawRamp / 10.0;\n        offset += 2;\n    }\n\n    // We can parse more if needed (Heart Rate, etc.)\n\n    return result;\n};\n","/**\n * Bluetooth Debug Service\n *\n * Handles capturing, storing, and exporting raw Bluetooth sensor data\n * for debugging purposes.\n */\n\nimport { saveDebugLog, getDebugLogs, clearDebugLogs } from '../../storage/workoutStorage.js';\nimport { getSettings } from '../../config/settings.js';\n\ntype DebugListener = (sensor: string, hex: string) => void;\n\n/**\n * Service for logging raw Bluetooth data\n */\nexport const BluetoothDebugService = {\n    listeners: new Set<DebugListener>(),\n\n    /**\n     * Check if debug mode is enabled\n     */\n    isEnabled(): boolean {\n        // Try to avoid excessive localStorage reads by checking if we are in a tight loop\n        // But getSettings parses JSON, so maybe we should cache this?\n        // for now, let's just read it.\n        const settings = getSettings();\n        return !!settings.debugMode;\n    },\n\n    /**\n     * Log a raw data packet\n     * @param sensor - The sensor type identifier\n     * @param data - The raw DataView from the Bluetooth characteristic\n     */\n    async log(sensor: string, data: DataView): Promise<void> {\n        // Always notify listeners, even if storage logging is disabled?\n        // Let's assume yes for the debug page to work without persisting.\n        const hex = this.bufferToHex(data.buffer);\n\n        this.listeners.forEach((listener) => listener(sensor, hex));\n\n        if (!this.isEnabled()) return;\n\n        try {\n            await saveDebugLog(sensor, hex);\n        } catch (e) {\n            console.warn('Failed to log debug data', e);\n        }\n    },\n\n    /**\n     * Add a listener for real-time debug data\n     */\n    addListener(listener: DebugListener): void {\n        this.listeners.add(listener);\n    },\n\n    /**\n     * Remove a listener\n     */\n    removeListener(listener: DebugListener): void {\n        this.listeners.delete(listener);\n    },\n\n    /**\n     * Convert ArrayBuffer to Hex string\n     */\n    bufferToHex(buffer: ArrayBufferLike): string {\n        return [...new Uint8Array(buffer)]\n            .map((b) => b.toString(16).padStart(2, '0'))\n            .join('')\n            .toUpperCase();\n    },\n\n    /**\n     * Export all logs as a JSON file\n     */\n    async exportLogs(): Promise<void> {\n        const logs = await getDebugLogs();\n        const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `bpt-debug-logs-${Date.now()}.json`;\n        document.body.appendChild(a);\n        a.click();\n\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    },\n\n    /**\n     * Clear all debug logs\n     */\n    async clearLogs(): Promise<void> {\n        await clearDebugLogs();\n    },\n\n    /**\n     * Get count of stored logs\n     */\n    async getLogCount(): Promise<number> {\n        const logs = await getDebugLogs();\n        return logs.length;\n    },\n};\n","import { BleClient } from '@capacitor-community/bluetooth-le';\nimport type {\n    SensorConnection,\n    TreadmillConnection,\n    MeasurementListener,\n    TreadmillListener,\n    ConnectionStatusListener,\n    ConnectionStatus,\n} from '../../types/bluetooth.js';\nimport type { Measurement, TreadmillMeasurement } from '../../types/measurements.js';\nimport { parseTreadmillData } from './ftms.js';\nimport { BluetoothDebugService } from '../debug/BluetoothDebugService.js';\n\nconst CYCLING_POWER_SERVICE = '00001818-0000-1000-8000-00805f9b34fb';\nconst CYCLING_POWER_MEASUREMENT = '00002a63-0000-1000-8000-00805f9b34fb';\n\nconst HEART_RATE_SERVICE = '0000180d-0000-1000-8000-00805f9b34fb';\nconst HEART_RATE_MEASUREMENT = '00002a37-0000-1000-8000-00805f9b34fb';\n\nconst CYCLING_SPEED_AND_CADENCE_SERVICE = '00001816-0000-1000-8000-00805f9b34fb';\nconst CSC_MEASUREMENT = '00002a5b-0000-1000-8000-00805f9b34fb';\n\nconst FITNESS_MACHINE_SERVICE = '00001826-0000-1000-8000-00805f9b34fb';\nconst TREADMILL_DATA_CHARACTERISTIC = '00002acd-0000-1000-8000-00805f9b34fb';\n\n/** Maximum reconnection attempts before giving up */\nconst MAX_RECONNECT_ATTEMPTS = 5;\n/** Base delay between reconnection attempts (ms) */\nconst RECONNECT_BASE_DELAY = 1000;\n\n// Track if BleClient has been initialized\nlet isBleInitialized = false;\n\nconst ensureBleInitialized = async () => {\n    if (!isBleInitialized) {\n        try {\n            await BleClient.initialize();\n            isBleInitialized = true;\n        } catch (error) {\n            console.error('Failed to initialize BleClient:', error);\n            // On some versions/platforms, re-initializing might throw but not be fatal if already initialized.\n            // But usually we want to propagate this error if it's the first time.\n            throw error;\n        }\n    }\n};\n\nexport const connectPowerNative = async (): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let deviceId: string | null = null;\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n\n    await ensureBleInitialized();\n\n    let device;\n    try {\n        device = await BleClient.requestDevice({\n            services: [CYCLING_POWER_SERVICE],\n            optionalServices: [],\n        });\n    } catch (error) {\n        console.error('Error requesting Power device:', error);\n        throw error;\n    }\n\n    deviceId = device.deviceId;\n    const deviceName = device.name || 'Power Sensor';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!deviceId) return;\n        await BleClient.connect(deviceId, onDisconnect);\n        notifyStatus('connected');\n\n        await BleClient.startNotifications(deviceId, CYCLING_POWER_SERVICE, CYCLING_POWER_MEASUREMENT, (value) => {\n            BluetoothDebugService.log(deviceName, value);\n            // Cycling power measurement format: bytes 2-3 contain instantaneous power (little-endian)\n            const power = value.getInt16(2, true);\n            const entry: Measurement = { timestamp: Date.now(), value: power };\n            listeners.forEach((listener) => listener(entry));\n        });\n        reconnectAttempts = 0;\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Native Power sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Native Power sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Native Power sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Native Power sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    const onDisconnect = (disconnectedDeviceId: string) => {\n        if (disconnectedDeviceId === deviceId && !isManualDisconnect) {\n            console.log('Native Power sensor: Disconnected');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    };\n\n    await connect();\n\n    return {\n        disconnect: async () => {\n            isManualDisconnect = true;\n            if (deviceId) {\n                try {\n                    await BleClient.stopNotifications(deviceId, CYCLING_POWER_SERVICE, CYCLING_POWER_MEASUREMENT);\n                    await BleClient.disconnect(deviceId);\n                } catch (e) {\n                    console.error('Error disconnecting native bluetooth:', e);\n                }\n            }\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectHeartRateNative = async (): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let deviceId: string | null = null;\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n\n    await ensureBleInitialized();\n\n    let device;\n    try {\n        device = await BleClient.requestDevice({\n            services: [HEART_RATE_SERVICE],\n            optionalServices: [HEART_RATE_SERVICE],\n        });\n    } catch (error) {\n        console.error('Error requesting Heart Rate device:', error);\n        throw error;\n    }\n\n    deviceId = device.deviceId;\n    const deviceName = device.name || 'Heart Rate Monitor';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!deviceId) return;\n        await BleClient.connect(deviceId, onDisconnect);\n        notifyStatus('connected');\n\n        await BleClient.startNotifications(deviceId, HEART_RATE_SERVICE, HEART_RATE_MEASUREMENT, (value) => {\n            BluetoothDebugService.log(deviceName, value);\n            const flags = value.getUint8(0);\n            let heartRate: number;\n\n            // Check Heart Rate Value Format bit (bit 0)\n            if (flags & 0x01) {\n                // UINT16\n                heartRate = value.getUint16(1, true); // little-endian\n            } else {\n                // UINT8\n                heartRate = value.getUint8(1);\n            }\n\n            const entry: Measurement = { timestamp: Date.now(), value: heartRate };\n            listeners.forEach((listener) => listener(entry));\n        });\n        reconnectAttempts = 0;\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Native Heart Rate sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Native Heart Rate sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Native Heart Rate sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Native Heart Rate sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    const onDisconnect = (disconnectedDeviceId: string) => {\n        if (disconnectedDeviceId === deviceId && !isManualDisconnect) {\n            console.log('Native Heart Rate sensor: Disconnected');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    };\n\n    await connect();\n\n    return {\n        disconnect: async () => {\n            isManualDisconnect = true;\n            if (deviceId) {\n                try {\n                    await BleClient.stopNotifications(deviceId, HEART_RATE_SERVICE, HEART_RATE_MEASUREMENT);\n                    await BleClient.disconnect(deviceId);\n                } catch (e) {\n                    console.error('Error disconnecting native bluetooth:', e);\n                }\n            }\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectCadenceNative = async (): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let deviceId: string | null = null;\n    let lastCrankRevs: number | null = null;\n    let lastCrankTime: number | null = null;\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n\n    await ensureBleInitialized();\n\n    let device;\n    try {\n        device = await BleClient.requestDevice({\n            services: [CYCLING_SPEED_AND_CADENCE_SERVICE],\n            optionalServices: [CYCLING_SPEED_AND_CADENCE_SERVICE],\n        });\n    } catch (error) {\n        console.error('Error requesting Cadence device:', error);\n        throw error;\n    }\n\n    deviceId = device.deviceId;\n    const deviceName = device.name || 'Cadence Sensor';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!deviceId) return;\n        await BleClient.connect(deviceId, onDisconnect);\n        notifyStatus('connected');\n\n        await BleClient.startNotifications(deviceId, CYCLING_SPEED_AND_CADENCE_SERVICE, CSC_MEASUREMENT, (value) => {\n            BluetoothDebugService.log(deviceName, value);\n            const flags = value.getUint8(0);\n\n            // Check if crank revolution data is present (bit 1 of flags)\n            if (flags & 0x02) {\n                let offset = 1; // Start after flags byte\n\n                // If wheel revolution data is present (bit 0), skip it (6 bytes: 4 for revs + 2 for time)\n                if (flags & 0x01) {\n                    offset = 7;\n                }\n\n                const crankRevs = value.getUint16(offset, true);\n                const crankTime = value.getUint16(offset + 2, true); // Units: 1/1024 seconds\n\n                // Calculate RPM from delta between measurements\n                if (lastCrankRevs !== null && lastCrankTime !== null) {\n                    let revDelta = crankRevs - lastCrankRevs;\n                    let timeDelta = crankTime - lastCrankTime;\n\n                    // Handle rollover (uint16 max is 65535)\n                    if (revDelta < 0) revDelta += 65536;\n                    if (timeDelta < 0) timeDelta += 65536;\n\n                    // Calculate RPM: (revolutions / time_in_seconds) * 60\n                    // Time is in 1/1024 seconds, so convert to seconds\n                    if (timeDelta > 0) {\n                        const timeInSeconds = timeDelta / 1024;\n                        const rpm = Math.round((revDelta / timeInSeconds) * 60);\n\n                        // Sanity check for reasonable cadence values\n                        if (rpm >= 0 && rpm < 300) {\n                            const entry: Measurement = { timestamp: Date.now(), value: rpm };\n                            listeners.forEach((listener) => listener(entry));\n                        }\n                    }\n                }\n\n                lastCrankRevs = crankRevs;\n                lastCrankTime = crankTime;\n            }\n        });\n        reconnectAttempts = 0;\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Native Cadence sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Native Cadence sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Native Cadence sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Native Cadence sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    const onDisconnect = (disconnectedDeviceId: string) => {\n        if (disconnectedDeviceId === deviceId && !isManualDisconnect) {\n            console.log('Native Cadence sensor: Disconnected');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    };\n\n    await connect();\n\n    return {\n        disconnect: async () => {\n            isManualDisconnect = true;\n            if (deviceId) {\n                try {\n                    await BleClient.stopNotifications(deviceId, CYCLING_SPEED_AND_CADENCE_SERVICE, CSC_MEASUREMENT);\n                    await BleClient.disconnect(deviceId);\n                } catch (e) {\n                    console.error('Error disconnecting native bluetooth:', e);\n                }\n            }\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectTreadmillNative = async (): Promise<TreadmillConnection> => {\n    const listeners: TreadmillListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let deviceId: string | null = null;\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n\n    await ensureBleInitialized();\n\n    let device;\n    try {\n        device = await BleClient.requestDevice({\n            services: [FITNESS_MACHINE_SERVICE],\n            optionalServices: [FITNESS_MACHINE_SERVICE],\n        });\n    } catch (error) {\n        console.error('Error requesting Treadmill device:', error);\n        throw error;\n    }\n\n    deviceId = device.deviceId;\n    const deviceName = device.name || 'Treadmill';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const onDisconnect = (disconnectedDeviceId: string) => {\n        if (disconnectedDeviceId === deviceId && !isManualDisconnect) {\n            console.log('Treadmill: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!deviceId) return;\n        await BleClient.connect(deviceId, onDisconnect);\n        notifyStatus('connected');\n\n        await BleClient.startNotifications(\n            deviceId,\n            FITNESS_MACHINE_SERVICE,\n            TREADMILL_DATA_CHARACTERISTIC,\n            (value) => {\n                BluetoothDebugService.log(deviceName, value);\n                try {\n                    const ftmsData = parseTreadmillData(value);\n\n                    if (ftmsData.speed !== undefined || ftmsData.incline !== undefined) {\n                        const entry: TreadmillMeasurement = {\n                            timestamp: Date.now(),\n                            speed: ftmsData.speed ?? null,\n                            incline: ftmsData.incline ?? null,\n                        };\n                        listeners.forEach((listener) => listener(entry));\n                    }\n                } catch (e) {\n                    console.error('Error parsing treadmill data', e);\n                }\n            }\n        );\n        reconnectAttempts = 0;\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect) return;\n\n        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            console.error('Treadmill: Max reconnection attempts reached');\n            notifyStatus('failed');\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Treadmill: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Treadmill: Reconnected successfully');\n        } catch (error) {\n            console.error('Treadmill: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    try {\n        await connect();\n    } catch (error) {\n        if (deviceId) {\n            try {\n                await BleClient.disconnect(deviceId);\n            } catch (e) {\n                /* ignore */\n            }\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: async () => {\n            isManualDisconnect = true;\n            if (deviceId) {\n                try {\n                    await BleClient.stopNotifications(deviceId, FITNESS_MACHINE_SERVICE, TREADMILL_DATA_CHARACTERISTIC);\n                    await BleClient.disconnect(deviceId);\n                } catch (e) {\n                    console.error('Error disconnecting treadmill', e);\n                }\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: TreadmillListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n","import type {\n    SensorConnection,\n    TreadmillConnection,\n    RowerConnection,\n    MeasurementListener,\n    TreadmillListener,\n    RowerListener,\n    ConnectionStatusListener,\n    ConnectionStatus,\n} from '../../types/bluetooth.js';\nimport type { Measurement, TreadmillMeasurement, RowerMeasurement } from '../../types/measurements.js';\nimport { parseTreadmillData } from './ftms.js';\nimport { BluetoothDebugService } from '../debug/BluetoothDebugService.js';\n\n/** Maximum reconnection attempts before giving up */\nconst MAX_RECONNECT_ATTEMPTS = 5;\n/** Base delay between reconnection attempts (ms) */\nconst RECONNECT_BASE_DELAY = 1000;\n\nexport const connectPowerWeb = async (): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n\n    // Request Bluetooth device with cycling power service\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['cycling_power'] }],\n        optionalServices: ['cycling_power'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Power Sensor';\n\n    /**\n     * Notify status listeners of connection status change\n     */\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    /**\n     * Handle characteristic value changes\n     */\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        // Cycling power measurement format: bytes 2-3 contain instantaneous power (little-endian)\n        const power = value.getInt16(2, true);\n        const entry: Measurement = { timestamp: Date.now(), value: power };\n        listeners.forEach((listener) => listener(entry));\n    };\n\n    /**\n     * Connect to the device and set up notifications\n     */\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        const server = await device.gatt.connect();\n        const service = await server.getPrimaryService('cycling_power');\n        characteristic = await service.getCharacteristic('cycling_power_measurement');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    /**\n     * Attempt to reconnect with exponential backoff\n     */\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Power sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Power sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Power sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Power sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    // Handle disconnection events\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Power sensor: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    // Initial connection\n    await connect();\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                characteristic.stopNotifications().catch(() => {});\n            }\n            device.gatt?.disconnect();\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectHeartRateWeb = async (): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n\n    // Request Bluetooth device with heart rate service\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['heart_rate'] }],\n        optionalServices: ['heart_rate'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Heart Rate Monitor';\n\n    /**\n     * Notify status listeners of connection status change\n     */\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    /**\n     * Handle characteristic value changes\n     */\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        const flags = value.getUint8(0);\n        let heartRate: number;\n\n        // Check Heart Rate Value Format bit (bit 0)\n        if (flags & 0x01) {\n            // UINT16\n            heartRate = value.getUint16(1, true); // little-endian\n        } else {\n            // UINT8\n            heartRate = value.getUint8(1);\n        }\n\n        const entry: Measurement = { timestamp: Date.now(), value: heartRate };\n        listeners.forEach((listener) => listener(entry));\n    };\n\n    /**\n     * Connect to the device and set up notifications\n     */\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        const server = await device.gatt.connect();\n        const service = await server.getPrimaryService('heart_rate');\n        characteristic = await service.getCharacteristic('heart_rate_measurement');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    /**\n     * Attempt to reconnect with exponential backoff\n     */\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Heart rate sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Heart rate sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Heart rate sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Heart rate sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    // Handle disconnection events\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Heart rate sensor: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    // Initial connection\n    await connect();\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                characteristic.stopNotifications().catch(() => {});\n            }\n            device.gatt?.disconnect();\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectCadenceWeb = async (): Promise<SensorConnection> => {\n    const listeners: MeasurementListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let lastCrankRevs: number | null = null;\n    let lastCrankTime: number | null = null;\n\n    // Request Bluetooth device with cycling speed and cadence service\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['cycling_speed_and_cadence'] }],\n        optionalServices: ['cycling_speed_and_cadence'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Cadence Sensor';\n\n    /**\n     * Notify status listeners of connection status change\n     */\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    /**\n     * Handle characteristic value changes\n     */\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        const flags = value.getUint8(0);\n\n        // Check if crank revolution data is present (bit 1 of flags)\n        if (flags & 0x02) {\n            // Crank revolution data format:\n            // - Cumulative Crank Revolutions (uint16, bytes 1-2 or 5-6 depending on wheel data)\n            // - Last Crank Event Time (uint16, bytes 3-4 or 7-8, units: 1/1024 seconds)\n\n            let offset = 1; // Start after flags byte\n\n            // If wheel revolution data is present (bit 0), skip it (6 bytes: 4 for revs + 2 for time)\n            if (flags & 0x01) {\n                offset = 7;\n            }\n\n            const crankRevs = value.getUint16(offset, true);\n            const crankTime = value.getUint16(offset + 2, true); // Units: 1/1024 seconds\n\n            // Calculate RPM from delta between measurements\n            if (lastCrankRevs !== null && lastCrankTime !== null) {\n                let revDelta = crankRevs - lastCrankRevs;\n                let timeDelta = crankTime - lastCrankTime;\n\n                // Handle rollover (uint16 max is 65535)\n                if (revDelta < 0) revDelta += 65536;\n                if (timeDelta < 0) timeDelta += 65536;\n\n                // Calculate RPM: (revolutions / time_in_seconds) * 60\n                // Time is in 1/1024 seconds, so convert to seconds\n                if (timeDelta > 0) {\n                    const timeInSeconds = timeDelta / 1024;\n                    const rpm = Math.round((revDelta / timeInSeconds) * 60);\n\n                    // Sanity check for reasonable cadence values\n                    if (rpm >= 0 && rpm < 300) {\n                        const entry: Measurement = { timestamp: Date.now(), value: rpm };\n                        listeners.forEach((listener) => listener(entry));\n                    }\n                }\n            }\n\n            lastCrankRevs = crankRevs;\n            lastCrankTime = crankTime;\n        }\n    };\n\n    /**\n     * Connect to the device and set up notifications\n     */\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        const server = await device.gatt.connect();\n        const service = await server.getPrimaryService('cycling_speed_and_cadence');\n        characteristic = await service.getCharacteristic('csc_measurement');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    /**\n     * Attempt to reconnect with exponential backoff\n     */\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Cadence sensor: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(\n            `Cadence sensor: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`\n        );\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Cadence sensor: Reconnected successfully');\n        } catch (error) {\n            console.error('Cadence sensor: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    // Handle disconnection events\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Cadence sensor: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    // Initial connection\n    await connect();\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                characteristic.stopNotifications().catch(() => {});\n            }\n            device.gatt?.disconnect();\n        },\n        addListener: (callback: MeasurementListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectTreadmillWeb = async (): Promise<TreadmillConnection> => {\n    const listeners: TreadmillListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n\n    // Request Bluetooth device with Fitness Machine Service\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['fitness_machine'] }],\n        optionalServices: ['fitness_machine'],\n    });\n\n    if (!device.gatt) {\n        throw new Error('GATT server not available');\n    }\n\n    const deviceName = device.name || 'Treadmill';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log(deviceName, value);\n\n        try {\n            const ftmsData = parseTreadmillData(value);\n\n            // Only emit if we have relevant data\n            if (ftmsData.speed !== undefined || ftmsData.incline !== undefined) {\n                const entry: TreadmillMeasurement = {\n                    timestamp: Date.now(),\n                    speed: ftmsData.speed ?? null,\n                    incline: ftmsData.incline ?? null,\n                };\n                listeners.forEach((listener) => listener(entry));\n            }\n        } catch (e) {\n            console.error('Error parsing treadmill data', e);\n        }\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n        characteristic = await service.getCharacteristic('treadmill_data');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Treadmill: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Treadmill: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Treadmill: Reconnected successfully');\n        } catch (error) {\n            console.error('Treadmill: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Treadmill: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    // Initial connection\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch (e) {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: TreadmillListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectRowingWeb = async (): Promise<RowerConnection> => {\n    const listeners: RowerListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n\n    // Request Bluetooth device with Fitness Machine Service\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services: ['fitness_machine'] }],\n        optionalServices: ['fitness_machine'],\n    });\n\n    const deviceName = device.name || 'Unknown Rower';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log('rower', value);\n\n        // Parsing logic would go here. For now just debug log is the priority.\n        const entry: RowerMeasurement = {\n            timestamp: Date.now(),\n            strokeRate: null,\n            power: null,\n        };\n        listeners.forEach((listener) => listener(entry));\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n        // 0x2AD1 is Rower Data\n        characteristic = await service.getCharacteristic('rower_data');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Rower: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Rower: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Rower: Reconnected successfully');\n        } catch (error) {\n            console.error('Rower: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Rower: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch (e) {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: RowerListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n\nexport const connectConcept2 = async (): Promise<RowerConnection> => {\n    const listeners: RowerListener[] = [];\n    const statusListeners: ConnectionStatusListener[] = [];\n    let isManualDisconnect = false;\n    let reconnectAttempts = 0;\n    let characteristic: BluetoothRemoteGATTCharacteristic | null = null;\n    let server: BluetoothRemoteGATTServer | undefined;\n\n    const C2_SERVICE_UUID = 'ce060030-43e5-11e4-916c-0800200c9a66';\n\n    // Request Bluetooth device with Fitness Machine Service\n    const device = await navigator.bluetooth.requestDevice({\n        filters: [{ namePrefix: 'PM5' }],\n        optionalServices: [C2_SERVICE_UUID],\n    });\n\n    const deviceName = device.name || 'Unknown concept2 Rower';\n\n    const notifyStatus = (status: ConnectionStatus) => {\n        statusListeners.forEach((listener) => listener(status));\n    };\n\n    const handleCharacteristicChange = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (!value) return;\n\n        BluetoothDebugService.log('concept2', value);\n\n        // Parsing logic would go here. For now just debug log is the priority.\n        const entry: RowerMeasurement = {\n            timestamp: Date.now(),\n            strokeRate: null,\n            power: null,\n        };\n        listeners.forEach((listener) => listener(entry));\n    };\n\n    const connect = async (): Promise<void> => {\n        if (!device.gatt) return;\n\n        server = await device.gatt.connect();\n        const service = await server.getPrimaryService('fitness_machine');\n        // 0x2AD1 is Rower Data\n        characteristic = await service.getCharacteristic('rower_data');\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicChange);\n\n        reconnectAttempts = 0;\n        notifyStatus('connected');\n    };\n\n    const attemptReconnect = async (): Promise<void> => {\n        if (isManualDisconnect || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n                console.error('Rower: Max reconnection attempts reached');\n                notifyStatus('failed');\n            }\n            return;\n        }\n\n        reconnectAttempts++;\n        const delay = RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts - 1);\n        console.log(`Rower: Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);\n        notifyStatus('reconnecting');\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n\n        try {\n            await connect();\n            console.log('Rower: Reconnected successfully');\n        } catch (error) {\n            console.error('Rower: Reconnection failed:', error);\n            attemptReconnect();\n        }\n    };\n\n    device.addEventListener('gattserverdisconnected', () => {\n        if (!isManualDisconnect) {\n            console.log('Rower: Connection lost, attempting to reconnect...');\n            notifyStatus('disconnected');\n            attemptReconnect();\n        }\n    });\n\n    try {\n        await connect();\n    } catch (error) {\n        if (server && server.connected) {\n            server.disconnect();\n        }\n        throw error;\n    }\n\n    return {\n        disconnect: () => {\n            isManualDisconnect = true;\n            if (characteristic) {\n                try {\n                    characteristic.stopNotifications();\n                    characteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicChange);\n                } catch (e) {\n                    /* ignore */\n                }\n            }\n            if (device.gatt?.connected) {\n                device.gatt.disconnect();\n            }\n            notifyStatus('disconnected');\n        },\n        addListener: (callback: RowerListener) => {\n            listeners.push(callback);\n        },\n        deviceName,\n        onStatusChange: (callback: ConnectionStatusListener) => {\n            statusListeners.push(callback);\n        },\n    };\n};\n","import { Capacitor } from '@capacitor/core';\nimport type { SensorConnection, TreadmillConnection, RowerConnection } from '../../types/bluetooth.js';\nimport {\n    connectPowerNative,\n    connectHeartRateNative,\n    connectCadenceNative,\n    connectTreadmillNative,\n} from './native-bluetooth.js';\nimport {\n    connectPowerWeb,\n    connectHeartRateWeb,\n    connectCadenceWeb,\n    connectTreadmillWeb,\n    connectRowingWeb,\n    connectConcept2,\n} from './web-bluetooth.js';\n\n/**\n * Bluetooth Factory\n *\n * Abstract factory for creating Bluetooth sensor connections.\n * Automatically selects the appropriate implementation (Web Bluetooth or Native)\n * based on the current platform.\n */\nexport const BluetoothFactory = {\n    /**\n     * Connect to a Power Meter\n     * @returns Promise resolving to a SensorConnection\n     */\n    connectPower: async (): Promise<SensorConnection> => {\n        if (typeof window !== 'undefined' && (window as any).useMockSensors) {\n            const { MockPowerSensor } = await import('./mock.js');\n            const sensor = new MockPowerSensor();\n            await sensor.connect();\n            (window as any).mockSensor = sensor;\n            return sensor;\n        }\n        if (Capacitor.isNativePlatform()) {\n            return connectPowerNative();\n        } else {\n            return connectPowerWeb();\n        }\n    },\n\n    /**\n     * Connect to a Heart Rate Monitor\n     * @returns Promise resolving to a SensorConnection\n     */\n    connectHeartRate: async (): Promise<SensorConnection> => {\n        if (typeof window !== 'undefined' && (window as any).useMockSensors) {\n            const { MockHeartrateSensor } = await import('./mock.js');\n            const sensor = new MockHeartrateSensor();\n            await sensor.connect();\n            (window as any).mockSensor = sensor;\n            return sensor;\n        }\n        if (Capacitor.isNativePlatform()) {\n            return connectHeartRateNative();\n        } else {\n            return connectHeartRateWeb();\n        }\n    },\n\n    /**\n     * Connect to a Cadence Sensor\n     * @returns Promise resolving to a SensorConnection\n     */\n    connectCadence: async (): Promise<SensorConnection> => {\n        if (typeof window !== 'undefined' && (window as any).useMockSensors) {\n            const { MockCadenceSensor } = await import('./mock.js');\n            const sensor = new MockCadenceSensor();\n            await sensor.connect();\n            (window as any).mockSensor = sensor;\n            return sensor;\n        }\n        if (Capacitor.isNativePlatform()) {\n            return connectCadenceNative();\n        } else {\n            return connectCadenceWeb();\n        }\n    },\n\n    /**\n     * Connect to a Treadmill\n     * @returns Promise resolving to a TreadmillConnection\n     */\n    connectTreadmill: async (): Promise<TreadmillConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            return connectTreadmillNative();\n        } else {\n            return connectTreadmillWeb();\n        }\n    },\n\n    /**\n     * Connect to a Rowing Machine\n     * @returns Promise resolving to a RowerConnection\n     */\n    connectRowing: async (): Promise<RowerConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native rowing connection not implemented');\n        } else {\n            return connectRowingWeb();\n        }\n    },\n\n    /**\n     * Connect to a Concept2 Rower\n     * @returns Promise resolving to a RowerConnection\n     */\n    connectConcept2: async (): Promise<RowerConnection> => {\n        if (Capacitor.isNativePlatform()) {\n            throw new Error('Native rowing connection not implemented');\n        } else {\n            return connectConcept2();\n        }\n    },\n};\n"],"file":"feature-bluetooth-WlFmxkI9.js"}