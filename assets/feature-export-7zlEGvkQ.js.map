{"version":3,"file":"feature-export-7zlEGvkQ.js","sources":["../../src/merge-measurements.ts","../../src/create-tcx.ts"],"sourcesContent":["/**\n * Measurement merging utilities\n * \n * Combines heart rate, cadence, and power measurements into synchronized data points.\n * \n * @module merge-measurements\n */\n\nimport type { Measurement, MeasurementsData } from './types/measurements.js';\n\n/**\n * A merged data point containing all measurement types at a single timestamp\n */\nexport interface MergedDataPoint {\n    timestamp: number;\n    heartrate: number | null;\n    cadence: number | null;\n    power: number | null;\n    speed: number | null;\n    distance: number | null;\n    altitude: number | null;\n    lat: number | null;\n    lon: number | null;\n    energy: number | null;\n}\n\n/**\n * Gets values from a measurement array at specific timestamps.\n * Uses nearest-neighbor interpolation with a 1000ms threshold.\n * \n * @param arr - Array of measurements sorted by timestamp\n * @param timestamps - Array of target timestamps to find values for\n * @returns Array of values (or null if no measurement within threshold)\n */\nexport const getValuesAtTimestamps = (\n    arr: Measurement[],\n    timestamps: number[]\n): (number | null)[] => {\n    const entries: (number | null)[] = [];\n    let index = 0;\n\n    for (const ts of timestamps) {\n        // Find the first measurement at or after the target timestamp\n        while (index < arr.length && arr[index].timestamp < ts) {\n            index++;\n        }\n\n        const prevIndex = index - 1;\n        let suggestedElem: Measurement | undefined = undefined;\n        const isAfterLastPoint = index >= arr.length;\n\n        if (prevIndex < 0) {\n            // Before first measurement - use first if available\n            suggestedElem = arr[index];\n        } else if (isAfterLastPoint) {\n            // After last measurement - use last\n            suggestedElem = arr[prevIndex];\n        } else {\n            // Between measurements - use nearest\n            const prevTime = arr[prevIndex]?.timestamp ?? 0;\n            const nextTime = arr[index]?.timestamp ?? 0;\n            suggestedElem = (ts - prevTime) <= (nextTime - ts) ? arr[prevIndex] : arr[index];\n        }\n\n        if (suggestedElem?.timestamp !== undefined) {\n            const distance = Math.abs(suggestedElem.timestamp - ts);\n            // Values must be strictly less than 1000ms away\n            if (distance < 1000) {\n                entries.push(suggestedElem.value);\n            } else {\n                entries.push(null);\n            }\n        } else {\n            entries.push(null);\n        }\n    }\n\n    return entries;\n};\n\n/**\n * Merges heart rate, cadence, and power measurements into synchronized data points.\n * \n * Creates a timeline with 1-second intervals from the earliest to the latest measurement,\n * then maps each measurement type to the nearest value at each timestamp.\n * \n * @param measurements - Object containing heartrate, cadence, and power measurement arrays\n * @returns Array of merged data points with all measurement types\n * \n * @example\n * const merged = mergeMeasurements({\n *   heartrate: [{ timestamp: 1000, value: 120 }],\n *   cadence: [{ timestamp: 1000, value: 80 }],\n *   power: [{ timestamp: 1000, value: 200 }]\n * });\n * // Returns: [{ timestamp: 1000, heartrate: 120, cadence: 80, power: 200 }]\n */\nexport const mergeMeasurements = (measurements: MeasurementsData): MergedDataPoint[] => {\n    // Convert GPS points to measurements for interpolation\n    const latMeasurements: Measurement[] = measurements.gps.map(p => ({ timestamp: p.timestamp, value: p.lat }));\n    const lonMeasurements: Measurement[] = measurements.gps.map(p => ({ timestamp: p.timestamp, value: p.lon }));\n    const energyData: Measurement[] = measurements.energy || [];\n\n    const sources = [\n        measurements.heartrate,\n        measurements.cadence,\n        measurements.power,\n        measurements.speed,\n        measurements.distance,\n        measurements.altitude,\n        latMeasurements,\n        energyData,\n    ];\n    const hasData = sources.some(data => data.length > 0);\n\n    if (!hasData) {\n        return [];\n    }\n\n    // Find the time range\n    const firstTimestamps = sources.map(data => data.length > 0 ? data[0].timestamp : Infinity);\n    const startTime = Math.min(...firstTimestamps);\n    const endTime = Math.max(\n        ...sources.map(data => data.length > 0 ? data[data.length - 1].timestamp : -Infinity)\n    );\n\n    // Create timestamps at 1-second intervals\n    const timeStep = 1000;\n    const timestamps: number[] = [];\n    let time = startTime;\n\n    while (time <= endTime) {\n        timestamps.push(time);\n        time += timeStep;\n    }\n\n    // Get synchronized values for each measurement type\n    const syncedHR = getValuesAtTimestamps(measurements.heartrate, timestamps);\n    const syncedCadence = getValuesAtTimestamps(measurements.cadence, timestamps);\n    const syncedPower = getValuesAtTimestamps(measurements.power, timestamps);\n    const syncedSpeed = getValuesAtTimestamps(measurements.speed, timestamps);\n    const syncedDistance = getValuesAtTimestamps(measurements.distance, timestamps);\n    const syncedAltitude = getValuesAtTimestamps(measurements.altitude, timestamps);\n    const syncedLat = getValuesAtTimestamps(latMeasurements, timestamps);\n    const syncedLon = getValuesAtTimestamps(lonMeasurements, timestamps);\n    const syncedEnergy = getValuesAtTimestamps(energyData, timestamps);\n\n    // Combine into data points\n    const dataPoints: MergedDataPoint[] = [];\n\n    for (let i = 0; i < timestamps.length; i++) {\n        dataPoints.push({\n            timestamp: timestamps[i],\n            heartrate: syncedHR[i],\n            cadence: syncedCadence[i],\n            power: syncedPower[i],\n            speed: syncedSpeed[i],\n            distance: syncedDistance[i],\n            altitude: syncedAltitude[i],\n            lat: syncedLat[i],\n            lon: syncedLon[i],\n            energy: syncedEnergy[i],\n        });\n    }\n\n    return dataPoints;\n};\n","/**\n * TCX (Training Center XML) export utilities\n * \n * Creates Garmin-compatible TCX files from workout measurements.\n * \n * @module create-tcx\n */\n\nimport { mergeMeasurements, type MergedDataPoint } from './merge-measurements.js';\nimport type { MeasurementsData, LapMarker } from './types/measurements.js';\nimport type { SportType } from './config/sport.js';\n\n/**\n * Map internal sport type to TCX Sport attribute\n * TCX supports: Running, Biking, Other\n */\nfunction getTcxSport(sport?: SportType): string {\n    switch (sport) {\n        case 'running':\n            return 'Running';\n        case 'walking':\n            return 'Other'; // TCX doesn't have Walking, use Other\n        case 'cycling':\n        default:\n            return 'Biking';\n    }\n}\n\n/**\n * Creates heart rate XML element\n */\nconst hrString = (hr: number | null): string =>\n    hr !== null ? `<HeartRateBpm><Value>${Math.round(hr)}</Value></HeartRateBpm>` : '';\n\n/**\n * Creates cadence XML element\n */\nconst cadenceString = (cadence: number | null): string =>\n    cadence !== null ? `<Cadence>${Math.round(cadence)}</Cadence>` : '';\n\n/**\n * Creates power XML element using Garmin extension format\n */\nconst powerString = (power: number | null): string => {\n    if (power === null) return '';\n    return `<Extensions>\n              <TPX xmlns=\"http://www.garmin.com/xmlschemas/ActivityExtension/v2\">\n                <Watts>${Math.round(power)}</Watts>\n              </TPX>\n            </Extensions>`;\n};\n\n/**\n * Creates a TCX trackpoint element from a merged data point\n * \n * @param point - Merged data point with timestamp and measurements\n * @returns TCX Trackpoint XML string\n */\nconst getTcxTrackpoint = (point: MergedDataPoint): string => {\n    const timestamp = new Date(point.timestamp).toISOString();\n\n    // Order matters in TCX schema: Time, Position, Altitude, Distance, HeartRate, Cadence, Extensions\n\n    let position = '';\n    if (point.lat !== null && point.lon !== null) {\n        position = `\n        <Position>\n            <LatitudeDegrees>${point.lat}</LatitudeDegrees>\n            <LongitudeDegrees>${point.lon}</LongitudeDegrees>\n        </Position>`;\n    }\n\n    let altitude = '';\n    if (point.altitude !== null) {\n        altitude = `<AltitudeMeters>${point.altitude}</AltitudeMeters>`;\n    }\n\n    let distance = '';\n    if (point.distance !== null) {\n        distance = `<DistanceMeters>${point.distance}</DistanceMeters>`;\n    }\n\n    const parts: string[] = [];\n\n    if (point.heartrate !== null) {\n        parts.push(hrString(point.heartrate));\n    }\n\n    if (point.cadence !== null) {\n        parts.push(cadenceString(point.cadence));\n    }\n\n    if (point.power !== null) {\n        parts.push(powerString(point.power));\n    }\n\n    return `\n<Trackpoint>\n    <Time>${timestamp}</Time>\n    ${position}\n    ${altitude}\n    ${distance}\n    ${parts.join('\\n')}\n</Trackpoint>\n    `.trim();\n};\n\n/**\n * Creates a Garmin TCX (Training Center XML) string from workout measurements.\n * \n * TCX is a standard format supported by most fitness platforms including\n * Strava, Garmin Connect, and TrainingPeaks.\n * \n * @param measurements - The measurements data object containing workout data\n * @param sport - Optional sport type for the activity (defaults to cycling)\n * @returns TCX formatted XML string\n * \n * @example\n * const tcx = getTcxString(measurementsState, 'running');\n * // Returns a valid TCX XML document with Running sport type\n */\nexport const getTcxString = (measurements: MeasurementsData, sport?: SportType): string => {\n    const dataPoints = mergeMeasurements(measurements);\n\n    if (!dataPoints || dataPoints.length === 0) {\n        return '';\n    }\n\n    const firstTimestamp = dataPoints[0].timestamp;\n    const lastTimestamp = dataPoints[dataPoints.length - 1].timestamp;\n    const startDate = new Date(firstTimestamp).toISOString();\n\n    // Build lap boundaries based on lap markers\n    const laps = measurements.laps || [];\n    const lapBoundaries = buildLapBoundaries(firstTimestamp, lastTimestamp, laps);\n\n    // Generate TCX lap elements\n    const lapElements = lapBoundaries.map((boundary, _index) => {\n        const lapDataPoints = dataPoints.filter(\n            p => p.timestamp >= boundary.start && p.timestamp < boundary.end\n        );\n\n        if (lapDataPoints.length === 0) return '';\n\n        const lapStartDate = new Date(boundary.start).toISOString();\n        const totalTimeSeconds = Math.round((boundary.end - boundary.start) / 1000);\n\n        // Calculate lap statistics\n        const avgHr = calculateAverage(lapDataPoints.map(p => p.heartrate));\n        const maxHr = calculateMax(lapDataPoints.map(p => p.heartrate));\n        const avgCadence = calculateAverage(lapDataPoints.map(p => p.cadence));\n        const avgPower = calculateAverage(lapDataPoints.map(p => p.power));\n\n        // Get distance if available\n        const distancePoints = lapDataPoints.filter(p => p.distance !== null);\n        const totalDistance = distancePoints.length > 0\n            ? (distancePoints[distancePoints.length - 1].distance! - (distancePoints[0].distance || 0))\n            : 0;\n\n        const validEnergyValues = lapDataPoints.filter(p => p.energy !== null);\n        const totalCalories = validEnergyValues.length > 0\n            ? (validEnergyValues[validEnergyValues.length - 1].energy! - (validEnergyValues[0].energy || 0))\n            : 0;\n\n        return `\n                <Lap StartTime=\"${lapStartDate}\">\n                    <TotalTimeSeconds>${totalTimeSeconds}</TotalTimeSeconds>\n                    <DistanceMeters>${Math.round(totalDistance)}</DistanceMeters>\n                    <Calories>${Math.round(totalCalories)}</Calories>\n                    ${avgHr !== null ? `<AverageHeartRateBpm><Value>${Math.round(avgHr)}</Value></AverageHeartRateBpm>` : ''}\n                    ${maxHr !== null ? `<MaximumHeartRateBpm><Value>${Math.round(maxHr)}</Value></MaximumHeartRateBpm>` : ''}\n                    <Intensity>Active</Intensity>\n                    <TriggerMethod>${boundary.isManual ? 'Manual' : 'Distance'}</TriggerMethod>\n                    ${avgCadence !== null ? `<Cadence>${Math.round(avgCadence)}</Cadence>` : ''}\n                    <Extensions>\n                        <LX xmlns=\"http://www.garmin.com/xmlschemas/ActivityExtension/v2\">\n                            ${avgPower !== null ? `<AvgWatts>${Math.round(avgPower)}</AvgWatts>` : ''}\n                        </LX>\n                    </Extensions>\n                    <Track>\n${lapDataPoints.map(getTcxTrackpoint).join('\\n')}\n                    </Track>\n                </Lap>`;\n    });\n\n    const tcxSport = getTcxSport(sport);\n    const tcx = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <TrainingCenterDatabase xmlns=\"http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2\">\n        <Activities>\n            <Activity Sport=\"${tcxSport}\">\n                <Id>${startDate}</Id>\n${lapElements.join('\\n')}\n            </Activity>\n        </Activities>\n    </TrainingCenterDatabase>`;\n\n    return tcx;\n};\n\n/**\n * Build lap boundaries from lap markers\n */\ninterface LapBoundary {\n    start: number;\n    end: number;\n    isManual: boolean;\n}\n\nfunction buildLapBoundaries(firstTimestamp: number, lastTimestamp: number, laps: LapMarker[]): LapBoundary[] {\n    if (laps.length === 0) {\n        // No laps, treat entire workout as one lap\n        return [{\n            start: firstTimestamp,\n            end: lastTimestamp + 1, // +1 to include last point\n            isManual: false,\n        }];\n    }\n\n    const boundaries: LapBoundary[] = [];\n    let currentStart = firstTimestamp;\n\n    for (const lap of laps) {\n        boundaries.push({\n            start: currentStart,\n            end: lap.timestamp,\n            isManual: true,\n        });\n        currentStart = lap.timestamp;\n    }\n\n    // Add final lap (from last marker to end)\n    boundaries.push({\n        start: currentStart,\n        end: lastTimestamp + 1,\n        isManual: false,\n    });\n\n    return boundaries;\n}\n\n/**\n * Calculate average of non-null values\n */\nfunction calculateAverage(values: (number | null)[]): number | null {\n    const validValues = values.filter((v): v is number => v !== null);\n    if (validValues.length === 0) return null;\n    return validValues.reduce((sum, v) => sum + v, 0) / validValues.length;\n}\n\n/**\n * Calculate max of non-null values\n */\nfunction calculateMax(values: (number | null)[]): number | null {\n    const validValues = values.filter((v): v is number => v !== null);\n    if (validValues.length === 0) return null;\n    return Math.max(...validValues);\n}\n"],"names":["getValuesAtTimestamps","arr","timestamps","entries","index","ts","prevIndex","suggestedElem","isAfterLastPoint","prevTime","nextTime","mergeMeasurements","measurements","latMeasurements","p","lonMeasurements","energyData","sources","data","firstTimestamps","startTime","endTime","timeStep","time","syncedHR","syncedCadence","syncedPower","syncedSpeed","syncedDistance","syncedAltitude","syncedLat","syncedLon","syncedEnergy","dataPoints","i","getTcxSport","sport","hrString","hr","cadenceString","cadence","powerString","power","getTcxTrackpoint","point","timestamp","position","altitude","distance","parts","getTcxString","firstTimestamp","lastTimestamp","startDate","laps","lapElements","buildLapBoundaries","boundary","_index","lapDataPoints","lapStartDate","totalTimeSeconds","avgHr","calculateAverage","maxHr","calculateMax","avgCadence","avgPower","distancePoints","totalDistance","validEnergyValues","totalCalories","boundaries","currentStart","lap","values","validValues","v","sum"],"mappings":"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"}